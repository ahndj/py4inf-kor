% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{조건부 실행}

\section{불 표현식(Boolean expressions)}
\index{불 표현식 (boolean expression)}
\index{표현식 (expression)!불 (boolean)}
\index{논리 연산자 (logical operator)}
\index{연산자 (operator)!논리 (logical)}
%\index{boolean expression}
%\index{expression!boolean}
%\index{logical operator}
%\index{operator!logical}

{\bf 불 표현식(boolean expression)}은 참(True) 혹은 거짓(False)를 지닌 표현식이다. 
다음 예제는 {\tt ==} 연산자를 사용하여 두 개 피연산자를 비교하여 값이 동일하면 {\tt 참(True)}, 그렇지 않으면 {\tt 거짓(False)}을 산출한다.

\beforeverb
\begin{verbatim}
>>> 5 == 5
True
>>> 5 == 6
False
\end{verbatim}
\afterverb
%

{\tt 참(True)}과 {\tt 거짓(False)}은 {\tt 불(bool)} 자료형(type)에 속하는 특별한 값이지만, 문자열은 아니다.

\index{참 특별값 (True special value)}
\index{거짓 특별값 (False special value)}
\index{특별값 (special value)!참 (True)}
\index{특별값 (special value)!거짓 (False)}
\index{불 자료형 (bool type)}
\index{자료형 (type)!불 (bool)}
%\index{True special value}
%\index{False special value}
%\index{special value!True}
%\index{special value!False}
%\index{bool type}
%\index{type!bool}

\beforeverb
\begin{verbatim}
>>> type(True)
<type 'bool'>
>>> type(False)
<type 'bool'>
\end{verbatim}
\afterverb
%

{\tt ==}연산자는 {\bf 비교 연산자(comparison operators)} 중 하나이고, 다른 연산자는 다음과 같다.

\beforeverb
\begin{verbatim}
      x != y               # x는 y와 값이 같지 않다.
      x > y                # x는 y보다 크다.
      x < y                # x는 y보다 작다.
      x >= y               # x는 y보다 크거나 같다.
      x <= y               # x는 y보다 작거나 같다.
      x is y               # x는 y와 같다.
      x is not y           # x는 y와 개체가 동일하지 않다.
\end{verbatim}
\afterverb
%
상기 연산자가 친숙할지 모르지만, 파이썬 기호는 수학 기호와 다르다. 
일반적인 오류로 비교를 해서 동일하다는 의미로 {\tt ==} 연산자 대신에 {\tt =}를 사용하는 것이다.
{\tt =} 연산자는 대입 연산자이고, {\tt ==}연산자는 비교 연산자다. 
{\tt =<}, {\tt =>} 같은 비교 연산자는 파이썬에는 없다.

\index{비교 연산자 (comparison operator)}
\index{연산자 (operator)!비교 (comparison)}
%\index{comparison operator}
%\index{operator!comparison}

\section {논리 연산자}
\index{논리 연산자 (logical operator)}
\index{연산자 (operator)!논리 (operator)}
%\index{logical operator}
%\index{operator!logical}

세개 {\bf 논리 연산자(logical operators)}: {\tt and}, {\tt or}, {\tt not} 가 있다. 
논리 연산자 의미는 영어 의미와 유사하다. 예를 들어,

{\tt x > 0 and x < 10} 

{\tt x} 가 0 보다 크다. \emph{그리고(and)}, 10 보다 작으면 참이다.

\index{and 연산자 (and operator)}
\index{or 연산자 (or operator)}
\index{not 연산자 (not operator)}
\index{연산자(operator)!and}
\index{연산자(operator)!or}
\index{연산자(operator)!not}

%\index{and operator}
%\index{or operator}
%\index{not operator}
%\index{operator!and}
%\index{operator!or}
%\index{operator!not}

{\tt n\%2 == 0 or n\%3 == 0}은 두 조건문 중의 하나만 참이 되면, 즉, 숫자가 2 \emph{혹은(or)} 3으로 나누어지면 참이다.

마지막으로 {\tt not} 연산자는 불 연산 표현식을 부정한다. 
{\tt x > y} 가 거짓이면, {\tt not (x > y)}은 참이다. 즉, {\tt x}이 {\tt y} 보다 작거나 같으면 참이다.

엄밀히 말해서, 논리 연산자의 두 피연산자는 모두 불 표현식이지만, 파이썬에서 그다지 엄격하지는 않다. 
0 이 아닌 임의의 숫자 모두 "참(true)"으로 해석된다.

\beforeverb
\begin{verbatim}
>>> 17 and True
True
\end{verbatim}
\afterverb
%

이러한 유연함이 유용할 수 있으나, 혼란을 줄 수도 있으니 유의해서 사용해야 한다. 
무슨 일을 하고 있는지 정확하게 알지 못한다면 피하는게 상책이다.

\section{조건문 실행}
%\label{conditional execution}

\index{조건문 (conditional statement)}
\index{문장 (statement)!조건 (conditional)}
\index{if문 (if statement)}
\index{문장 (statement)!if}
\index{조건문 실행 (conditional execution)}
%\index{conditional statement}
%\index{statement!conditional}
%\index{if statement}
%\index{statement!if}
%\index{conditional execution}

유용한 프로그램을 작성하기 위해서 거의 항상 조건을 확인하고 조건에 따라 프로그램 실행을 바꿀 수 있어야 한다.
{\bf 조건문(Conditional statements)}은 그러한 능력을 부여한다. 
가장 간단한 형태는  {\tt if} 문이다.

\beforeverb
\begin{verbatim}
if x > 0 :
    print 'x is positive'
\end{verbatim}
\afterverb
%
{\tt if}문 뒤에 불 표현식(boolean expression)을 {\bf 조건(condition)}이라고 한다.

\beforefig
\centerline{\includegraphics[height=1.75in]{figs2/if.eps}}
\afterfig

만약 조건문이 참이면, 들여쓰기 된 문장이 실행된다. 
만약 조건문이 거짓이면, 들여쓰기 된 문장의 실행을 건너뛴다.

\index{조건 (condition)}
\index{복합 문장 (compound statement)}
\index{문장 (statement)!복합 (compound)}
%\index{condition}
%\index{compound statement}
%\index{statement!compound}

{\tt if}문은 함수 정의, {\tt for} 반복문과 동일한 구조를 가진다.
{\tt if}문은 콜론(:)으로 끝나는 헤더 머리부문과 들여쓰기된 몸통 블록(block)으로 구성된다.
{\tt if}문처럼 문장이 한 줄 이상에 걸쳐 작성되기 때문에 {\bf 복합 문장(compound statements)}이라고 한다.

{\tt if}문 몸통 부문에 작성되는 실행 문장 숫자에 제한은 없으나 최소한 한 줄은 있어야 한다.
때때로, 몸통 부문에 어떤 문장도 없는 경우가 있다. 
아직 코드를 작성하지 않아서 자리만 잡아 놓는 경우로, 아무것도 수행하지 않는 {\tt pass}문을 사용할 수 있다.

\index{pass 문장 (pass statement)}
\index{문장 (statement)!pass}
%\index{pass statement}
%\index{statement!pass}

\beforeverb
\begin{verbatim}
if x < 0 :
    pass          # 음수값을 처리 예정!
\end{verbatim}
\afterverb
%
if문을 파이썬 인터프리터에서 타이핑하고 엔터를 치게 되면, 
명령 프롬프트가 갈매기 세마리에서 점 세개로 바뀐다. 
따라서 다음과 같이 if문 몸통 부분을 작성중에 있다는 것을 나타낸다.

\beforeverb
\begin{verbatim}
>>> x = 3
>>> if x < 10:
...    print 'Small'
... 
Small
>>>
\end{verbatim}
\afterverb
%

\section{대안 실행}
%\label{alternative execution}

\index{대안 실행 (alternative execution)}
\index{else 예약어 (else keyword)}
\index{예약어 (keyword)!else}
%\index{alternative execution}
%\index{else keyword}
%\index{keyword!else}

{\tt if}문의 두 번째 형태는 {\bf 대안 실행(alternative execution)}이다.
대안 실행의 경우 두 가지 경우의 수가 존재하고, 조건이 어느 방향으로 실행할 것인지 결정한다. 
구문(Syntax)은 아래와 같다.

\beforeverb
\begin{verbatim}
if x%2 == 0 :
    print 'x is even'
else :
    print 'x is odd'
\end{verbatim}
\afterverb
%
{\tt x}를 2로 나누었을 때, 0 이되면, {\tt x}는 짝수이고, 프로그램은 짝수('x is even')라는 결과 메시지를 출력한다. 
만약 조건이 거짓이라면, 두 번째 몸통 부문 문장이 실행된다.

\beforefig
\centerline{\includegraphics[height=1.75in]{figs2/if-else.eps}}
\afterfig

조건은 참 혹은 거짓이어서, 대안 중 하나만 정확하게 실행된다. 
대안을 {\bf 분기(Branch)}라고도 하는데 이유는 실행 흐름이 분기되기 때문이다.

\index{분기 (branch)}
%\index{branch}

\section{연쇄 조건문}
\index{연쇄 조건문 (chained conditional)}
\index{조건문 (conditional)!연쇄 (chained)}
%\index{chained conditional}
%\index{conditional!chained}

때때로, 두 가지 이상의 경우의 수가 있으며, 두 가지 이상의 분기가 필요하다.
이와 같은 연산을 표현하는 방식이 {\bf 연쇄 조건문(chained conditional)}이다.

\beforeverb
\begin{verbatim}
if x < y:
    print 'x is less than y'
elif x > y:
    print 'x is greater than y'
else:
    print 'x and y are equal'
\end{verbatim}
\afterverb
%
{\tt elif}는 ''else if''의 축약어이다. 이번에도 단 한번의 분기만 실행된다.

\beforefig
\centerline{\includegraphics[height=3.00in]{figs2/elif.eps}}
\afterfig

{\tt elif} 문의 갯수에 제한은 없다. 
{\tt else} 절이 있다면, 거기서 끝마쳐야 하지만, 연쇄 조건문에 필히 있어야 하는 것은 아니다.

\index{elif 예약어 (elif keyword)}
\index{예약어 (keyword)!elif}
%\index{elif keyword}
%\index{keyword!elif}

\beforeverb
\begin{verbatim}
if choice == 'a':
    print 'Bad guess'
elif choice == 'b':
    print 'Good guess'
elif choice == 'c':
    print 'Close, but not correct'
\end{verbatim}
\afterverb
%
각 조건은 순서대로 점검한다. 만약 첫 번째가 거짓이면, 다음을 점검하고 계속 점검해 나간다.
순서대로 진행 중에 하나의 조건이 참이면, 해당 분기가 수행되고, {\tt if}문 전체는 종료된다. 
설사 하나 이상의 조건이 참이라고 하더라도, 첫 번째 참 분기만 수행된다.

\section{중첩 조건문}
\index{중첩 조건문 (nested conditional)}
\index{조건문 (conditional)!중첩 (nested)}
%\index{nested conditional}
%\index{conditional!nested}

하나의 조건문이 조건문 내부에 중첩될 수 있다. 
다음과 같이 삼분 예제를 작성할 수 있다.

\beforeverb
\begin{verbatim}
if x == y:
    print 'x and y are equal'
else:
    if x < y:
        print 'x is less than y'
    else:
        print 'x is greater than y'
\end{verbatim}
\afterverb
%

바깥 조건문에는 두 개의 분기가 있다. 
첫 분기는 간단한 문장을 담고 있다. 
두 번째 분기는 자체가 두 개의 분기를 가지고 있는 또 다른 {\tt if}문을 담고 있다.
자체로 둘다 조건문이지만, 두 분기 모두 간단한 문장이다.

\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/nested.eps}}
\afterfig

문장을 들여쓰는 것이 구조를 명확히 하지만, \bf{중첩 조건문}의 경우 가독성이 급격히 저하된다. 
일반적으로, 가능하면 중첩 조건문을 피하는 것을 권장한다.

논리 연산자를 사용하여 중첩 조건문을 간략히 할 수 있다. 
예를 들어, 단일 조건문으로 가지고 앞의 코드를 다음과 같이 재작성할 수 있다.

\beforeverb
\begin{verbatim}
if 0 < x:
    if x < 10:
        print 'x is a positive single-digit number.'
\end{verbatim}
\afterverb
%

{\tt print}문은 두 개 조건문을 통과될 때만 실행돼서, {\tt and} 연산자와 동일한 효과를 거둘 수 있다.

\beforeverb
\begin{verbatim}
if 0 < x and x < 10:
    print 'x is a positive single-digit number.'
\end{verbatim}
\afterverb


\section{try와 catch를 활용한 예외 처리}
%\label{catch1}

함수 \verb"raw_input"와 {\tt int}을 사용하여 앞에서 사용자가 타이핑한 숫자를 읽어 정수로 파싱하는 프로그램 코드를 살펴보았다.
또한 이렇게 코딩하는 것이 얼마나 위험한 것인지도 살펴보았다.

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
>>>
\end{verbatim}
\afterverb
%
파이썬 인터프리터에서 상기 문장을 실행하면, 
인터프리터에서 새로운 프롬프트로 되고, "이런(oops)" 잠시 후에, 다음 문장 실행으로 넘어간다.

하지만, 만약 코드가 파이썬 스크립트로 실행이 되어 오류가 발생하면,
역추적해서 그 지점에서 즉시 멈추게 된다. 다음에 오는 문장은 실행하지 않는다.

\index{역추적 (traceback)}
%\index{traceback}

화씨 온도를 섭씨 온도로 변환하는 간단한 프로그램이 있다.

\index{화씨 (fahrenheit)}
\index{섭씨 (celsius)}
\index{온도 변환 (temperature conversion)}
%\index{fahrenheit}
%\index{celsius}
%\index{temperature conversion}

\beforeverb
\begin{verbatim}
inp = raw_input('Enter Fahrenheit Temperature:')
fahr = float(inp)
cel = (fahr - 32.0) * 5.0 / 9.0
print cel
\end{verbatim}
\afterverb
%

이 코드를 실행해서 적절하지 않은 입력값을 넣게 되면, 다소 불친절한 오류 메시지와 함께 간단히 작동을 멈춘다.

\beforeverb
\begin{verbatim}
python fahren.py 
Enter Fahrenheit Temperature:72
22.2222222222

python fahren.py 
Enter Fahrenheit Temperature:fred
Traceback (most recent call last):
  File "fahren.py", line 2, in <module>
    fahr = float(inp)
ValueError: invalid literal for float(): fred
\end{verbatim}
\afterverb
%

이런 종류의 예측하거나, 예측하지 못한 오류를 다루기 위해서 파이썬에는 ``try / except''로 불리는 조건 실행 구조가 내장되어 있다.
{\tt try}와 {\tt except}의 기본적인 생각은 일부 명령문에 문제가 있다는 것을 사전에 알고 있고, 
만약 그 때문에 오류가 발생하게 된다면 대신 프로그램에 추가해서 명령문을 실행한다는 것이다. 
{\tt except} 블록의 문장은 오류가 없다면 실행되지 않는다.

문장 실행에 대해서 파이썬 {\tt try}, {\tt except} 기능을 보험으로 생각할 수도 있다.

온도 변환기 프로그램을 다음과 같이 재작성한다.

\beforeverb
\begin{verbatim}
inp = raw_input('Enter Fahrenheit Temperature:')
try:
    fahr = float(inp)
    cel = (fahr - 32.0) * 5.0 / 9.0
    print cel
except:
    print 'Please enter a number'
\end{verbatim}
\afterverb
%

파이썬은 {\tt try} 블록 문장을 우선 실행한다. 
만약 모든 것이 순조롭다면, {\tt except} 블록을 건너뛰고, 다음 코드를 실행한다.
만약 {\tt try} 블록에서 {\tt except}이 발생하면, 
파이썬은 {\tt try} 블록에서 빠져 나와 {\tt except}블록 문장을 수행한다.

\beforeverb
\begin{verbatim}
python fahren2.py 
Enter Fahrenheit Temperature:72
22.2222222222

python fahren2.py 
Enter Fahrenheit Temperature:fred
Please enter a number
\end{verbatim}
\afterverb
%

{\tt try}문으로 예외사항을 다루는 것을 {\bf 예외 처리한다(catching an exception)}고 부른다.
예제에서 {\tt except} 절에서는 단순히 오류 메시지를 출력만 한다. 
대체로, 예외 처리를 통해서 오류를 고치거나, 재시작하거나, 최소한 프로그램이 정상적으로 종료될 수 있게 한다.

\section{논리 연산식의 단락(Short circuit) 평가}
\index{단락 (short circuit)}

{\tt x >= 2 and (x/y) > 2}와 같은 논리 표현식을 파이썬에서 처리할 때, 왼쪽에서부터 오른쪽으로 표현식을 평가한다.
{\tt and} 정의 때문에 {\tt x} 가 2보다 작다면, {\tt x >= 2}은 {\tt 거짓(False)}으로, 
전체적으로 {\tt (x/y) > 2} 이 {\tt 참(True)} 혹은 {\tt 거짓(False)} 이냐에 관계없이 {\tt 거짓(False)}이 된다. 

나머지 논리 표현식을 평가해도 나아지는 것이 없다고 파이썬이 자동으로 탐지할 때,
평가를 멈추고 나머지 논리 표현식에 대한 연산도 중지한다. 
최종값이 이미 결정되었기 때문에 더 이상의 논리 표현식의 평가가 멈출 때, 이를 단락(Short-circuiting) 평가라고 한다.

\index{가디언 패턴 (guardian pattern)}
\index{패턴 (패턴)!가디언 (guardian)}
%\index{guardian pattern}
%\index{pattern!guardian}

좋은 점처럼 보일 수 있지만, 단락 행동은 {\bf 가디언 패턴(guardian pattern)}으로 불리는 좀 더 똑똑한 기술로 연계된다.
파이썬 인터프리터의 다음 코드를 살펴보자.

\beforeverb
\begin{verbatim}
>>> x = 6 
>>> y = 2
>>> x >= 2 and (x/y) > 2
True
>>> x = 1 
>>> y = 0
>>> x >= 2 and (x/y) > 2
False
>>> x = 6
>>> y = 0
>>> x >= 2 and (x/y) > 2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>> 
\end{verbatim}
\afterverb
%

세번째 연산은 실패하는데 이유는 {\tt (x/y)} 연산을 평가할 때 {\tt y} 가 0 이어서 실행오류 발생한다.
하지만, 두 번째 예제의 경우 실패하지 않는데 이유는 {\tt x >= 2} 이 {\tt 거짓(False)} 으로, 
전체가 {\tt 거짓(False)}이 되어 단락(Short-circuiting) 평가 규칙에 의해 {\tt (x/y)} 평가는 실행되지 않아 오류도 발생하지 않는다.

평가 오류를 발생하기 전에 {\bf 가디언(gardian)} 평가식을 전략적으로 배치해서 논리 표현식을 다음과 같이 구성한다. 

\beforeverb
\begin{verbatim}
>>> x = 1
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x = 6 
>>> y = 0
>>> x >= 2 and y != 0 and (x/y) > 2
False
>>> x >= 2 and (x/y) > 2 and y != 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero
>>>
\end{verbatim}
\afterverb
%
첫 번째 논리 표현식은 {\tt x >= 2} 이 {\tt 거짓(False)} 이라 {\tt and}에서 멈춘다.
두 번째 논리 표현식은 {\tt x >= 2} 이 {\tt 참(True)}, {\tt y != 0}은 {\tt 거짓(False)} 이라 {\tt (x/y)}까지 갈 필요가 없다.
세 번째 논리 표현식은 {\tt (x/y)} 연산이 끝난 후에 {\tt y != 0} 이 수행되어서 오류가 발생한다.

두 번째 표현식에서 {\tt y} 가 0 이 아닐 때만, {\tt (x/y)}을 실행하도록 {\tt y != 0} 이 {\bf 가디언(gardian)} 역할을 수행한다고 말할 수 있다.

\section{디버깅(Debugging)}
%\label{whitespace}
\index{디버깅 (debugging)}
\index{역추적 (traceback)}
%\index{debugging}
%\index{traceback}

오류가 발생했을 때, 파이썬 화면에 출력되는 역추적(traceback)에는 상당한 정보가 담겨있다. 
하지만,특히 스택에 많은 프레임이 있는 경우 엄청나게 보여 엄두가 나지 않을 수도 있다.
대체로 가장 유용한 정보는 다음과 같은 것이 있다.

\begin{itemize}

\item 어떤 종류의 오류인가.

\item 어디서 발생했는가.

\end{itemize}

구문 오류는 대체로 발견하기 쉽지만, 몇 가지는 애매하다. 공백(space)과 탭(tab)의 차이가 눈에 보이지 않아 
통상 무시하고 넘어가기 쉽기 때문에 공백 오류를 잡아내기가 까다롭다.

\index{공백 (whitespace)}

\beforeverb
\begin{verbatim}
>>> x = 5
>>>  y = 6
  File "<stdin>", line 1
    y = 6
    ^
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
상기 예제 문제는 두 번째 줄에 한 칸 공백이 들여써서 발생하는 것이다. 
하지만, {\tt y}에 오류 메시지가 있는데 프로그래머를 잘못된 곳으로 인도한다. 
대체로 오류 메시지는 문제가 어디에서 발견되었는지를 지칭하지만, 실제 오류는 코드 앞에 종종 선행하는 줄에 있을 수 있다.

\index{오류 (error)!실행 (runtime)}
\index{실행 오류 (runtime error)}
%\index{error!runtime}
%\index{runtime error}

동일한 문제가 실행 오류에도 있다. 
데시벨(decibels)로 신호 대비 잡음비를 계산한다고 가정하자. 
공식은 $SNR_{db} = 10 \log_{10} (P_{signal} / P_{noise})$ 이다. 
파이썬에서 아래와 같이 작성할 수 있다.

\beforeverb
\begin{verbatim}
import math
signal_power = 9
noise_power = 10
ratio = signal_power / noise_power
decibels = 10 * math.log10(ratio)
print decibels
\end{verbatim}
\afterverb
%

하지만, 실행하게 되면, 다음과 같은 오류 메시지\footnote{파이썬 3.0에서는 오류 메시지가 발생하지 않는다.
 정수 피연산자인 경우에도 나눗셈 연산자가 부동 소수점 나눗셈을 수행한다.}가 발생한다. 

\index{예외 (exception)!오버플로 오류 (OverflowError)}
\index{오버플로 오류 (OverflowError)}
%\index{exception!OverflowError}
%\index{OverflowError}

\beforeverb
\begin{verbatim}
Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibels = 10 * math.log10(ratio)
OverflowError: math range error
\end{verbatim}
\afterverb
%

오류 메지지가 5번째 줄에 있다고 지칭하지만, 잘못된 것은 없다. 
실제 오류를 발견하기 위해서, 
출력값이 0 인 {\tt ratio} 값을 {\tt print}문을 사용해서 출력하는 것이 도움이 된다.
문제는 4번째 줄에 있는데, 왜냐하면 두 정수를 나눌 때 내림 나눗셈을 했기 때문입니다. 
\verb"signal_power" 와 \verb"noise_power" 를 부동 소수점값으로 표현하는게 해결책이다.

\index{내림 나눗셈 (floor division)}
\index{나눗셈 (division)!내림 (floor)}
%\index{floor division}
%\index{division!floor}

대체로, 오류 메시지는 문제가 어디에서 발견되었는지를 알려주지만, 
종종 문제의 원인이 어디에서 발생했는지는 알려주지 않는다.

\section{용어 정의}

\begin{description}

\item[몸통 부문(body):] 복합 문장 내부에 일련의 문장문
\index{몸통 부문 (body)}
%\index{body}

\item[불 표현식(boolean expression):] {\tt 참(True)} 혹은 {\tt 거짓(False)}의 값을 가지는 표현식
\index{불 표현식 (boolean expression)}
\index{표현식 (expression)!불 (boolean)}
%\index{boolean expression}
%\index{expression!boolean}

\item[분기(branch):] 조건문에서 대안 문장의 한 흐름
\index{분기 (branch)}
%\index{branch}

\item[연쇄 조건문(chained conditional):] 일련의 대안 분기가 있는 조건문
\index{연쇄 조건문 (chained conditional)}
\index{조건문 (conditional)!연쇄 (chained)}
%\index{chained conditional}
%\index{conditional!chained}

\item[비교 연산자(comparison operator):] 피연산자를 {\tt ==}, {\tt !=}, {\tt >}, {\tt <}, {\tt >=}, {\tt <=}로 비교하는 연산자

\item[조건문(conditional statement):] 조건에 따라 명령의 흐름을 제어하는 명령문
\index{조건문 (conditional statement)}
\index{문장 (statement)!조건문 (conditional)}
%\index{conditional statement}
%\index{statement!conditional}

\item[조건(condition):] 조건문에서 어느 분기를 실행할지 결정하는 불 표현식
\index{조건 (condition)}
%\index{condition}

\item[복합문(compound statement):] 머리부문(head)과 몸통부문(body)으로 구성된 문장.
머리부문은 콜론(:)으로 끝나며, 몸통부문은 머리부문을 기준으로 들여쓰기로 구별된다.
\index{복합문 (compound statement)}
%\index{compound statement}

\item[가디언 패턴(guardian pattern):] 단락(short circuit) 행동을 잘 이용하도록 논리 표현식을 구성하는 것
\index{가디언 패턴 (guardian pattern)}
\index{패턴 (pattern)!가디언 (guardian)}
%\index{guardian pattern}
%\index{pattern!guardian}

\item[논리 연산자(logical operator):] 불 표현식을 결합하는 연산자 중의 하나 ({\tt and}, {\tt or}, {\tt not})

\item[중첩 조건문(nested conditional):] 하나의 조건문이 다른 조건문 분기에 나타나는 조건문.
\index{중첩 조건문 (nested conditional)}
\index{조건문 (conditional)!중첩 (nested)}
%\index{nested conditional}
%\index{conditional!nested}

\item[역추적(traceback):] 예외 사항이 발생했을 때 실행되고, 출력되는 함수 리스트
\index{역추적 (traceback)}
%\index{traceback}

\item[단락(short circuit):] 나머지 표현식 평가를 할 필요없이 최종 결과를 알기 때문에,
파이썬이 논리 표현식 평가를 진행하는 중간에 평가를 멈출 때.
\index{단락 (short circuit)}
%\index{short circuit}

\end{description}

\section{연습문제}

\begin{ex}
40시간 이상 일할 경우 시급을 1.5배 더 종업원에게 지급하는 봉급계산 프로그램을 다시 작성하세요.

\begin{verbatim}
Enter Hours: 45
Enter Rate: 10
Pay: 475.0
\end{verbatim}
\end{ex}

\begin{ex}
{\tt try}, {\tt except}를 사용하여 봉급계산 프로그램을 다시 작성하세요.
숫자가 아닌 입력값을 잘 처리해서 숫자 아닌 입력값이 들어왔을 때 메시지를 출력하고 정상적으로 프로그램을 종료하도록 합니다.
다음이 프로그램 출력 결과를 보여줍니다.

\begin{verbatim}
Enter Hours: 20
Enter Rate: nine
Error, please enter numeric input

Enter Hours: forty
Error, please enter numeric input
\end{verbatim}
\end{ex}

\begin{ex}
0.0과 1.0 사이의 점수를 출력하는 프로그램을 작성하세요.
만약 점수가 범위 밖이면 오류를 출력합니다. 
만약 점수가 0.0과 1.0 사이라면, 다음의 테이블에 따라 등급을 출력합니다.

\begin{verbatim}
Score   Grade
>= 0.9     A
>= 0.8     B
>= 0.7     C
>= 0.6     D
< 0.6    F

Enter score: 0.95
A

Enter score: perfect
Bad score

Enter score: 10.0
Bad score

Enter score: 0.75
C

Enter score: 0.5
F
\end{verbatim}
상기 보이는 것처럼 반복적으로 프로그램을 실행해서 다양한 다른 입력값을 테스트해 보세요.
\end{ex}

