% The contents of this file is 
% Copyright (c) 2009-  Charles R. Severance, All Righs Reserved

\chapter{데이터베이스와 SQL(Structured Query Language) 사용하기}

\section{데이터베이스가 뭔가요?}
\index{database}

{\bf 데이터베이스(database)}는 데이터를 저장하기 위한 목적으로 조직된 파일이다. 
대부분의 데이터베이스는 키(key)와 값(value)를 매핑한다는 의미에서 딕셔너리 처럼 조직되었다.
가장 큰 차이점은 데이터베이스는 디스크(혹은 다른 영구 저장소)에 위치하게 되어서, 프로그램 종료 후에도 정보가 지속적으로 저장된다.
데이터베이스가 영구 저장소에 저장되어서, 컴퓨터의 메모리 크기에 제한을 받는 딕셔너리보다 훨씬 더 많은 정보를 저장할 수 있다.

\index{database!indexes}

딕셔너리처럼, 데이터베이스 소프트웨어는 엄청난 양의 데이터 조차도 매우 빠르게 삽입하고 접근하도록 설계되었다.
컴퓨터가 특정 항목으로 빠르게 넘어갈 수 있도록 데이터베이스에 데이터를 추가하여 {\bf 인덱스(indexes)}를 구축하여 성능을 보장하는 것이 데이터베이스 소프트웨어다.

다양한 종류의 목적에 사용되는 서로 다른 많은 데이터베이스 시스템이 있다. Oracle, MySQL, Microsoft SQL Server, 
PostgreSQL, SQLite이 여기에 포함된다. SQLite를 집중해서 살펴볼 것이다. 왜냐하면 매우 일반적인 데이터베이스이고 파이썬에 이미 내장되어 있기 때문이다.
SQLite는 응용프로그램 내부에서 데이터베이스 지원을 제공하도록 다른 응용프로그램에 \emph{내장(embedded)}되도록 설계되었다.
예를 들어, 다른 많은 소프트웨어 제품이 그렇듯이, 파이어폭스 브라우져는 SQLite를 사용한다.

\url{http://sqlite.org/}

이번 장에서 기술하는 트위터 스파이더링 응용프로그램같은 인포매틱스(Informatics)에서 마주치는 몇몇 데이터 조작 문제에 SQLite가 적합하다.


\section{데이터베이스 개념}
처음 데이터베이스를 볼때 드는 생각은 마치 엑셀같은 다중 시트를 지닌 스프레드쉬트(spreadsheet)같다.
데이터베이스의 주요 데이터구조는 {\bf 테이블(tables)}, {\bf 행(rows)}, and {\bf 열(columns)}이다.  

\beforefig
\centerline{\includegraphics[height=1.50in]{figs2/relational.eps}}
\afterfig

관계형 데이터베이스의 기술적은 설명으로 테이블, 행, 열의 개념은 {\bf 관계(relation)}, {\bf 튜플(tuple)}, and {\bf 속성(attribute)} 각각 형식적으로 참조된다.
이번장에서는 좀더 덜 형식 용어를 사용한다.

\section{파이어폭스 애드온 SQLite 매니저}
SQLite 데이터베이스 파일에 데이터를 다루기 위해서 이번장에서 파이썬의 사용에 집중을 하지만, 다음 웹사이트에서 무료로 이용가능한
{\bf SQLite 데이터베이스 매니저(SQLite Database Manager)}로 불리는 파이어폭스 애드온을 사용해서 좀더 쉽게 많은 연산을 수행한다.

\url{https://addons.mozilla.org/en-us/firefox/addon/sqlite-manager/}

브라우져를 사용해서 쉽게 테이블을 생성하고, 데이터를 삽입, 편집하고 데이터베이스의 데이터에 간단한 SQL 질의를 실행할 수 있다.

이러한 점에서 데이터베이스 매니저는 텍스트 파일을 작업할 때 사용하는 텍스트 편집기와 유사하다.
텍스트 파일에 하나 혹은 몇개의 작업을 하고자 하면, 텍스트 편집기에 파일을 열어 원하는 수정을 하면 된다.
텍스트 파일에 작업할 사항이 많은 경우는 종종 간단한 파이썬 프로그램을 작성한다. 
데이터베이트로 작업할 때 동일한 패턴을 찾을 수 있다. 간단한 작업은 데이터베이스 매니저를 통해서 수행하고,
좀더 복잡한 작업은 파이썬으로 수행하는 것이 가장 편리하다.


\section{데이터베이스 테이블 생성하기}

데이터베이스는 파이썬 리스트 혹은 딕셔너리보다 좀더 명확히 정의된 구조를 요구한다.\footnote{
SQLite 실질적으로 열에 저장되는 데이터 형식에 좀더 많은 유연성을 부여하지만,
이번 장에서는 데이터 형식을 엄격하게 유지해서 MySQL 같은 다른 데이터베이스 시스템에도 동일하게 개념이 적용되게 한다.}.  

데이터베이스 {\bf 테이블(table)}을 생성할 때, 데이터베이스에게 테이블의 각 {\bf 열(column)}의 명칭과 각 {\bf 열(column)}에
저장하려고 하는 테이터의 형식을 미리 알려줘야 한다.
데이터베이스 소프트웨어가 각 열의 데이터 형식을 인식하게 되면, 데이터 형식에 따라 가장 효율적으로 데이터를 저장하고 찾아오는 방법을 선택할 수 있다.

다음 url에서 SQLite에서 지원하는 다양한 데이터 형식을 볼 수 있다.

\url{http://www.sqlite.org/datatypes.html}

처음에는 사전에 데이터 구조를 정의하는 것이 불편하게 보이지만, 데이터베이스가 대량의 데이터를 포함하는 경우에도 데이터의 빠른 접근을 보장하는 잇점이 있다.

데이터베이스 파일과 데이터베이스에 두개의 열을 가진 {\tt Tracks} 이름의 테이블을 생성하는 코드는 다음과 같다.

\index{sqlite3 module}
\index{module!sqlite3}
\beforeverb
\begin{verbatim}
import sqlite3

conn = sqlite3.connect('music.sqlite3')
cur = conn.cursor()

cur.execute('DROP TABLE IF EXISTS Tracks ')
cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')

conn.close()
\end{verbatim}
\afterverb
%

\index{connect function}
\index{function!connect}
\index{cursor function}
\index{function!cursor}

{\tt connect} 연산은 현재 디렉토리의 {\tt music.sqlite3} 파일에 저장된 데이터베이스에 ''연결(connection)''한다.
파일이 존재하지 않으면, 자동 생성이 된다. ''연결(connection)''이라고 부르는 이유는 때때로 데이터베이스가 응용프로그램이 실행되는 서버로부터
분리된 ''데이터베이스 서버(database server)''에 저장되기 때문이다.
여기 간단한 예제에서는 데이터베이스가 실행되는 파이썬 코드처럼 동일한 디렉토리에 로컬 파일이다.

{\bf 커서(cursor)}는 파일을 다루는 파일핸들러처럼 데이터베이스에 저장된 파일에 연산을 수행하기 위해서 사용한다.
{\tt cursor()}를 호출하는 것은 개념적으로 텍스트 파일을 다룰 때 {\tt open()}을 호출하는 것과 개념적으로 매우 유사하다.

\beforefig
\centerline{\includegraphics[height=1.50in]{figs2/cursor.eps}}
\afterfig

커서가 생성되면, {\tt execute()} 메쏘드를 사용하여 데이터베이스 콘텐츠에 명령어 실행을 할 수 있다.

데이터베이스 명령어는 특별한 언어로 표현되어 단 하나의 데이터베이스 언어를 학습하도록 서로 다른 많은 데이터베이스 업체사이에서 표준화되었다.
데이터베이스 언어는 {\bf SQL(Structured Query Language 구조적 질의 언어)}로 불린다.

\url{http://en.wikipedia.org/wiki/SQL}

상기 예제에서, 데이터베이스에 두개의 SQL 명령어를 실행했다. 관습적으로 데이터베이스 키워드는 대문자로 테이블이나 열의 명칭처럼 사용자가 추가한
명령어 부분은 소문자로 표기한다.

첫 SQL 명령어는 만약 존재한다면 데이터베이스에서 {\tt Tracks} 테이블을 삭제한다.
이런 형태의 패턴은 단순하게 오류 없이 반복적으로 {\tt Tracks} 테이블을 생성하도록 동일한 프로그램을 실행할 수 있게 한다.
{\tt DROP TABLE} 명령어는 데이터베이스로부터 테이블 및 테이블 콘텐츠 전부를 삭제함을 주목하세요. (즉, ''실행취소(undo)''가 없다.)

\beforeverb
\begin{verbatim}
cur.execute('DROP TABLE IF EXISTS Tracks ')
\end{verbatim}
\afterverb
%

두번째 명령어는 {\tt title} 문자형 열과 {\tt plays} 정수형 열을 가진 {\tt Tracks}으로 명명된 테이블을 생성한다.

\beforeverb
\begin{verbatim}
cur.execute('CREATE TABLE Tracks (title TEXT, plays INTEGER)')
\end{verbatim}
\afterverb
%

이제 {\tt Tracks}로 명명된 테이블을 생성했으니, SQL {\tt INSERT} 연산을 통해서 테이블에 데이터를 넣을 수 있다.
다시 한번, 데이터베이스에 연결하여 {\tt 커서(cursor)}를 얻어서 작업을 시작한다. 그리고 나서 커서를 사용하여 SQL 명령어를 수행한다.

SQL {\tt INSERT} 명령어는 어느 테이블을 사용하는지, {\tt (title, plays) }을 포함하는 필드를 통해서 신규 행을 정의하고 
테이블의 신규 행에 {\tt VALUES}에 해당 데이터를 입력한다.
실제 값이 {\tt execute()} 호출의 두번째 매개변수로 {\tt ( 'My Way', 15 ) } 튜플로 넘겨는 것을 표기하기 위해서 값을 물음표 {\tt (?, ?)}로 명기한다.

\beforeverb
\begin{verbatim}
import sqlite3

conn = sqlite3.connect('music.sqlite3')
cur = conn.cursor()

cur.execute('INSERT INTO Tracks (title, plays) VALUES ( ?, ? )', 
    ( 'Thunderstruck', 20 ) )
cur.execute('INSERT INTO Tracks (title, plays) VALUES ( ?, ? )', 
    ( 'My Way', 15 ) )
conn.commit()

print 'Tracks:'
cur.execute('SELECT title, plays FROM Tracks')
for row in cur :
   print row

cur.execute('DELETE FROM Tracks WHERE plays < 100')
conn.commit()

cur.close()
\end{verbatim}
\afterverb
%

먼저 테이블에 두개의 열을 {\tt 삽입(INSERT)}하고 {\tt commit()}을 사용하여 데이터가 데이터베이스에 써지도록 했다.

\beforefig
\centerline{\includegraphics[height=1.00in]{figs2/tracks.eps}}
\afterfig

그리고 나서, {\tt SELECT} 명령어를 사용하여 테이블에 방금전에 삽입된 행을 불러왔다.
{\tt SELECT} 명령어에 어느 열{\tt (title, plays)}을 가져오는지와 어느 테이블{\tt Tracks}에서 데이터를 가져올지를 나타낸다.
{\tt SELECT} 명령문을 수행한 후에, 커서는 {\tt for}문의 반복을 수행하는 것과 같다.
효율성을 위해서, 커서는 {\tt SELECT} 명령문을 수행할 때 데이터베이스에서 모든 데이터를 읽지 않는다. 
대신에 데이터는 {\tt for}문의 행을 반복하듯이 요청시에만 읽어온다.

프로그램 실행결과는 다음과 같다.

\beforeverb
\begin{verbatim}
Tracks:
(u'Thunderstruck', 20)
(u'My Way', 15)
\end{verbatim}
\afterverb
%
\index{Unicode}

{\tt for} 루프는 두개의 행을 읽어왔다. 각각의 행은 {\tt title}로 첫번째 값을,
{\tt plays}로 두번째 값을 가진 파이썬 튜플이다. title 문자열이 'u'로 시작한다고 걱정하지 마라.
해당 문자열은 라틴 문자가 아닌 다국어를 저장할 수 있는 {\bf 유니코드(Unicode)} 문자열을 나타내는 것이다.

프로그램 마지막에 SQL 명령어를 실행서 방금전에 생성한 행을 모두 {\tt 삭제(DELETE)}했서
프로그램을 다시금 실행할 수 있다. {\tt 삭제(DELETE)} 명령어는 {\tt WHERE} 문을 사용하여 선택 조건을 표기할 수 있다.
따라서 명령문이 조건을 충족하는 행에만 데이터베이스에 적용된다.
이번 예제에서 기준이 모든 행에 적용되어서 테이블에 아무 것도 없게 되어서 프로그램을 반복적으로 실행할 수 있다.
{\tt 삭제(DELETE)}를 실행한 후에 {\tt commit()}을 호출하여 데이터가 데이터베이스에서 와전히 제거되게 했다.

\section{SQL(Structured Query Language) 요약}

지금까지, 파이썬 예제에서 SQL(Structured Query Language)을 사용했고, SQL 명령어의 기본에 대해서 다루었다.
이번 장에서는 SQL 언어를 보고 SQL 구문 개요를 살펴본다.

대단히 많은 데이터베이스 업체가 존재하기 때문에 SQL(Structured Query Language)은 표준화가 많이 진행되었고,
여러 업체로부터 데이터베이스 시스템에 이식가능한 방식으로 의사소통이 가능하다.

관계형 데이터베이스는 테이블, 행과 열로 구성되어 있다. 행은 일반적으로 텍스트, 숫자, 혹은 날짜 형식의 데이터 형식이다.
테이블을 생성할 때, 열의 명칭과 형식을 지정한다.

\beforeverb
\begin{verbatim}
CREATE TABLE Tracks (title TEXT, plays INTEGER)
\end{verbatim}
\afterverb
%

테이블에 행을 삽입하기 위해서 SQL {\tt INSERT} 명령어를 사용한다.

\beforeverb
\begin{verbatim}
INSERT INTO Tracks (title, plays) VALUES ('My Way', 15)
\end{verbatim}
\afterverb
%

{\tt INSERT} 명령문은 테이블 이름을 명기하고 나서 새로운 행에 넣고 싶은 필드/행 리스트를 명시한다.
그리고 나서 키워드 {\tt VALUES}와 각 필드에 해당 값을 넣는다.

SQL {\tt SELECT} 명령어는 데이터베이스에서 행과 열을 가져오기 위해 사용된다.
{\tt SELECT} 명령문은 가져오고자 하는 행과 {\tt WHERE}절을 사용하여 어느 행을 가져올지를 지정한다.
선택사항으로 {\tt ORDER BY} 절을 이용하여 반환되는 행을 정렬할 수도 있다.

\beforeverb
\begin{verbatim}
SELECT * FROM Tracks WHERE title = 'My Way'
\end{verbatim}
\afterverb
%

\verb"*" 을 사용하여 {\tt WHERE} 절에 매칭되는 행의 모든 열을 데이터베이스에서 가져온다.

주목할 점은 파이썬과 달리 SQL {\tt WHERE} 절은 등식을 시험하기 위해서 두개의 등치 기호 보다 하나의 등치 기호를 사용한다.
{\tt WHERE}에서 인정되는 다른 논리 연산자는 
\verb"<",
\verb">",
\verb"<=",
\verb">=",
\verb"!=" 이고, 논리 표현식을 생성하는데 {\tt AND}와 {\tt OR}도 사용된다.

다음과 같이 반환되는 열이 필드값 중에 하나에 따라 정렬할 수도 있다.

\beforeverb
\begin{verbatim}
SELECT title,plays FROM Tracks ORDER BY title
\end{verbatim}
\afterverb
%

행을 제거하기 위해서, SQL {\tt DELETE} 명령문에 {\tt WHERE} 절이 필요하다.
{\tt WHERE} 절이 어느 행이 삭제될지 결정한다.

\beforeverb
\begin{verbatim}
DELETE FROM Tracks WHERE title = 'My Way'
\end{verbatim}
\afterverb
%

다음과 같이 SQL {\tt UPDATE} 명령문을 사용하여 테이블의 하나 혹은 그 이상의 행의 열을 {\tt 갱신(UPDATE)}한다.

\beforeverb
\begin{verbatim}
UPDATE Tracks SET plays = 16 WHERE title = 'My Way'
\end{verbatim}
\afterverb
%

{\tt UPDATE} 명령문은 테이블과 필드 리스트, 그리고 {\tt SET} 키워드 후에 바뀔 값을 명시한다.
그리고 선택사항으로 {\tt WHERE}절로 갱신될 열을 지정한다. 
단일 {\tt UPDATE} 명령문은 {\tt WHERE}절에 매칭되는 모든 행을 바꾼다. 만약 {\tt WHERE}절이 지정되지 않으면,
테이블의 모든 행에 대해서 {\tt 갱신(UPDATE)}을 한다.

4가지 기본 SQL 명령문(INSERT, SELECT, UPDATE, and DELETE)은 데이터를 생성하고 유지관리하는데 필요한 기본적인 4가지 작업을 가능케 한다.

\section{데이터베이스를 사용한 트위터 스파이더링(Spidering)}

이번장에서 트위커 계정을 통하고 계정 데이터베이스를 생성하는 간단한 스파이더링 프로그램을 작성합니다.
\emph{주의: 프로그램을 실행할 때 매우 주의하세요. 여러분의 트위터 계정의 접속이 차단될 정도로 너무 많은 데이터를 가져오거나 
장 시간 프로그램을 실행하지 마세요.}

임의의 스파이더링 프로그램이 가지는 문제점 중의 하나는 중단되거나 여러번 재시작할 필요가 생겨서
지금까지 가져온 데이터를 여러분은 잃고 싶지 않습니다.
처음에 데이터 가져오기를 항상 다시 시작하고 싶지 않고,
데이터를 가져오면 저장하길 원한다.
그래서 프로그램이 저장을 시작할 수 있고, 중단한 곳에서 다시 가져오길 원합니다.

한 사람의 트위터 친구와 상태 정보를 가져오는 것에서, 친구의 리스트에서 반복적으로 적용하고, 친구 각각을 향후에 가져올 수 있도록 데이터베이스에 추가하여 시작한다. 
한 사람의 트위터 친구를 처리한 후에 테이터베이스를 확인하고 친구의 친구 한명을 가져온다. 이것을 반복하고, ''방문하지 않는(unvisited)'' 친구를 선택하고,
친구의 리스트를 가져오고 향후 방문을 위해서 리스트에 보지 않은 친구로 추가한다.

''인기도(popularity)''를 측정하도록 데이터베이스에 특별한 친구를 얼마나 자주 봤는지를 기록한다.

알고 있는 계정 리스트르 저장함으로써, 혹은 계정을 가져왔는 혹은 그렇지 않은지, 그리고 계정이 컴퓨터 디스크의 데이터베이스에서 얼마나 인기있는지에 따라
원하는 만큼 프로그램을 멈추거나 다시 시작할 수 있다.

% TODO: Add a reference to the right spot
프로그램이 약간 복잡하다. 트위터 API를 사용한 책의 앞뽁 예제에서 가져온 코드에 기반한다.

다음은 트위터 스파이더링 응용프로그램의 소스코드다.

\beforeverb
\begin{verbatim}
import urllib
import twurl
import json
import sqlite3

TWITTER_URL = 'https://api.twitter.com/1.1/friends/list.json'

conn = sqlite3.connect('spider.sqlite3')
cur = conn.cursor()

cur.execute('''
CREATE TABLE IF NOT EXISTS Twitter 
(name TEXT, retrieved INTEGER, friends INTEGER)''')

while True:
    acct = raw_input('Enter a Twitter account, or quit: ')
    if ( acct == 'quit' ) : break
    if ( len(acct) < 1 ) :
        cur.execute('SELECT name FROM Twitter WHERE retrieved = 0 LIMIT 1')
        try:
            acct = cur.fetchone()[0]
        except:
            print 'No unretrieved Twitter accounts found'
            continue

    url = twurl.augment(TWITTER_URL, 
               {'screen_name': acct, 'count': '20'} )
    print 'Retrieving', url
    connection = urllib.urlopen(url)
    data = connection.read()
    headers = connection.info().dict
    # print 'Remaining', headers['x-rate-limit-remaining']
    js = json.loads(data)
    # print json.dumps(js, indent=4)

    cur.execute('UPDATE Twitter SET retrieved=1 WHERE name = ?', (acct, ) )

    countnew = 0
    countold = 0
    for u in js['users'] :
        friend = u['screen_name']
        print friend
        cur.execute('SELECT friends FROM Twitter WHERE name = ? LIMIT 1', 
            (friend, ) )
        try:
            count = cur.fetchone()[0]
            cur.execute('UPDATE Twitter SET friends = ? WHERE name = ?', 
                (count+1, friend) )
            countold = countold + 1
        except:
            cur.execute('''INSERT INTO Twitter (name, retrieved, friends) 
                VALUES ( ?, 0, 1 )''', ( friend, ) )
            countnew = countnew + 1
    print 'New accounts=',countnew,' revisited=',countold
    conn.commit()

cur.close()
\end{verbatim}
\afterverb
%

데이터베이스는  {\tt spider.sqlite3} 파일에 저장되어 있다. 
{\tt Twitter}로 이름 붙은 테이블과 {\tt Twitter} 테이블의 각 행은 계정 이름,
계정의 친구를 가져왔는지, 그리고 이 계정이 얼마나 많이 ''친구추가(friended)'' 되었는지로 구성되었다.

프로그램의 메인 루프에서 트위터 계정 이름을 사용자가 입력하거나 프로그램을 나가기 위해서 ''끝내기(quit)''를 
입력한다. 사용자가 트위터 계정을 입력하면, 친구 리스트와 상태정보도 가져온다. 
만약 데이터베이스에 있지 않다면 데이터베이스에 친구로 추가한다.
만약 친구가 이미 리스트에 존재한다면, 데이터베이싀 행에 {\tt friends} 필드에 추가한다.

사용자가 엔터키를 누르면, 아직 가져오지 않은 다음 트위터 계정의 데이터베이스를 살펴보고,
친구와 그 계정의 상태 정보를 가져오고, 데이터베이스에 추가하거나 갱신하고, {\tt friends count}를 증가한다.

친구 리스트와 상태정보를 가져왔으면 JSON 형식의 {\tt user} 항목을 반복을 돌려 각 사용자의 
\verb"screen_name"을 가져온다. 그리고 나서 {\tt SELECT }문을 사용하여 데이터베이스에 
\verb"screen_name"이 저장되었는지, 레코드가 존재하면 친구 숫자({\tt friends})를 확인한다.

\beforeverb
\begin{verbatim}
    countnew = 0
    countold = 0
    for u in js['users'] :
        friend = u['screen_name']
        print friend
        cur.execute('SELECT friends FROM Twitter WHERE name = ? LIMIT 1', 
            (friend, ) )
        try:
            count = cur.fetchone()[0]
            cur.execute('UPDATE Twitter SET friends = ? WHERE name = ?', 
                (count+1, friend) )
            countold = countold + 1
        except:
            cur.execute('''INSERT INTO Twitter (name, retrieved, friends) 
                VALUES ( ?, 0, 1 )''', ( friend, ) )
            countnew = countnew + 1
    print 'New accounts=',countnew,' revisited=',countold
    conn.commit()
\end{verbatim}
\afterverb
%

커서가 {\tt SELECT}문을 수행하면 행을 가져온다. 
{\tt for}문으로 동일한 작업을 할 수 있지만, 단지 하나의 행({\tt LIMIT 1})만을 가져오기 때문에,
{\tt SELECT} 처리 결과의 첫번째만 가져오는 {\tt fetchone()} 메쏘드를 사용한다.
{\tt fetchone()}은 행을 설사 하나의 필드만 있더라도 {\bf 튜플(tuple)}로 반환하기 때문에,
 {\tt [0]}을 사용해서 튜플로부터 첫번째 값을 얻어 {\tt count} 변수에 현재 친구 숫자를 구한다.

정상적으로 데이터를 가져오면, SQL {\tt WHERE}절을 가진 {\tt UPDATE}문을 사용하여
친구의 계정에 매칭되는 행에 대해서 {\tt friends} 열에 추가한다.
SQL에 두 개의 자리표시기(placeholder, 물음표)가 있고, {\tt execute()}의 두 매개변수는 
물음표 자리에 SQL 안으로 치환될 값을 가진 두 요소 튜플이다.

만약 {\tt try} 블록에서 코드가 작동하지 않는다면, 아마도 {\tt SELECT} 문의
{\tt WHERE name = ?} 절에서 매칭되는 레코드가 없기 때문이다.
그래서, {\tt except} 블록에서, SQL {\tt INSERT}문을 사용하여 
\verb"screen_name"을 가져온 적이 없고 친구 숫자를 0으로 설정해서 
친구의 \verb"screen_name"을 테이블에 추가한다. 

처음 프로그램을 실행하고 트위터 계정을 입력하면, 프로그램이 다음과 같이 실행된다.

\beforeverb
\begin{verbatim}
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit: quit
\end{verbatim}
\afterverb
%

프로그램을 실행한 처음이어서, 데이터베이스는 비여있고, 
{\tt spider.sqlite3} 파일에 데이터베이스를 생성하고, {\tt Twitter} 테이블을 추가한다.
그리고 나서 친구를 가져오고 데이터베이스가 비여있기 때문에 모든 친구를 추가한다.

이 지점에서 {\tt spider.sqlite3} 파일에 무엇이 있는지를 살펴보기 위해서 간단한 데이터베이스 덤퍼(dumper)를 작성한다.

\beforeverb
\begin{verbatim}
import sqlite3

conn = sqlite3.connect('spider.sqlite3')
cur = conn.cursor()
cur.execute('SELECT * FROM Twitter')
count = 0
for row in cur :
   print row
   count = count + 1
print count, 'rows.'
cur.close()
\end{verbatim}
\afterverb
%

상기 프로그램은 데이터베이스를 열고 {\tt Twitter} 테이블의 모든 행과 열을 선택하고 
모든 행에 루프를 돌려 각 행을 출력한다.

앞서 작성한 트위터 스파이더를 실행한 후에 이 프로그램을 실행하면, 출력 결과는 다음과 같다.

\beforeverb
\begin{verbatim}
(u'opencontent', 0, 1)
(u'lhawthorn', 0, 1)
(u'steve_coppin', 0, 1)
(u'davidkocher', 0, 1)
(u'hrheingold', 0, 1)
...
20 rows.
\end{verbatim}
\afterverb
%

각 \verb"screen_name"에 대해 한 행만 있다. \verb"screen_name"의 데이터를 가져오지 않아서 데이터베이스의 모두는 한 명의 친구가 있다. 

이제 데이터베이스는 트위터 계정 ({\bf drchuck})에서 친구를 가져온 것을 확인했다.
프로그램을 반복적으로 실행해서 
다음과 같이 트위터 계정 대신에 엔터키를 누름으로써 다음 ''처리되지 않은'' 계정의 친구를 가져오게 한다.

\beforeverb
\begin{verbatim}
Enter a Twitter account, or quit: 
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 18  revisited= 2
Enter a Twitter account, or quit: 
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
\end{verbatim}
\afterverb
%

엔터키를 누를 떄(즉, 트위터 계정을 명시하지 않았을 때), 다음 코드가 수행된다.

\beforeverb
\begin{verbatim}
    if ( len(acct) < 1 ) :
        cur.execute('SELECT name FROM Twitter WHERE retrieved = 0 LIMIT 1')
        try:
            acct = cur.fetchone()[0]
        except:
            print 'No unretrieved twitter accounts found'
            continue
\end{verbatim}
\afterverb
%

SQL {\tt SELECT}문을 사용해서 첫 사용자({\tt LIMIT 1})의 이름을 가져온다.
''사용자를 가져왔는가''의 값은 여전히 0으로 설정되어 있다.
try/except 블록 내부에 {\tt fetchone()[0]} 패턴을 사용하여 가져온 데이터에서 \verb"screen_name"을 
추출하던가 혹은 오류 메시지를 출력하고 다시 돌아간다.

처리되지 않은 \verb"screen_name"을 성공적으로 가져오면, 다음과 같이 데이터를 읽어온다.

\beforeverb
\begin{verbatim}
    url = twurl.augment(TWITTER_URL, {'screen_name': acct, 'count': '20'} )
    print 'Retrieving', url
    connection = urllib.urlopen(url)
    data = connection.read()
    js = json.loads(data)

    cur.execute('UPDATE Twitter SET retrieved=1 WHERE name = ?', (acct, ) )
\end{verbatim}
\afterverb
%

데이터를 성공적으로 가져오면 {\tt UPDATE}문을 사용하여 
이 계정의 친구 가져오기를 완료했는지 표기하기 위해서 {\tt retrieved} 열에 표시한다.
이렇게 함으로써 반복적으로 동일한 데이터를 가져오지 않게 하고 트위터 친구 네트워크를 타고 
앞으로 나갈 수 있게 한다.

친구 프로그램을 실행하고 다음 방문하지 않은 친구의 친구 정보를 가져오기 위해서
두번 엔터를 누르고, 결과값을 확인하는 프로그램을 실행하면, 다음 출력값을 얻게 된다.

\beforeverb
\begin{verbatim}
(u'opencontent', 1, 1)
(u'lhawthorn', 1, 1)
(u'steve_coppin', 0, 1)
(u'davidkocher', 0, 1)
(u'hrheingold', 0, 1)
...
(u'cnxorg', 0, 2)
(u'knoop', 0, 1)
(u'kthanos', 0, 2)
(u'LectureTools', 0, 1)
...
55 rows.
\end{verbatim}
\afterverb
%

{\tt lhawthorn}과 {\tt opencontent}을 방문한 이력이 잘 기록됨을 확인한다.
{\tt cnxorg}과 {\tt kthanos} 계정은 이미 두 명의 팔로워(follower)가 있다.
세명({\tt drchuck}, {\tt opencontent}, {\tt lhawthorn}) 친구를 가져와서, 테이블은 55 친구 행이 생겼다.

매번 프로그램을 실행하고 엔터키를 누를 때마다, 다음 방문하지 않은(예, 다음 계정은 \verb"steve_coppin") 계정을
선택해서, 친구 목록을 가져오고, 가져온 것으로 표기하고, \verb"steve_coppin" 친구 각각을 데이터베이스 끝에
추가하고 데이터베이스에 이미 추가되어 있으면 친구 숫자를 갱신한다.

프로그램의 데이터가 모두 데이터베이스 디스크에 저장되어서, 스파이더링을 잠시 보류할 수 있고,
데이터 손실 없이 원하는만큼 다시 시작할 수 있다.

\section{데이터 모델링 기초}

관계형 데이터베이스의 진정한 힘은 다중 테이블과 테이블 사이의 관계를 생성할 때다.
응용프로그램의 데이터를 쪼개서 다중 테이블과 두 테이블 사이의 관계를 설정하는 결정을 
{\bf 데이터 모델링(data modeling)}이라고 한다. 테이블과 테이블 관계를 보여주는 설계 문서를 
{\bf 데이터 모델(data model)}이라고 한다.

데이터 모델링은 상대적으로 고급 기술이여서 이번 장에서는 관계형 데이터 모델링의 가장 기본적인 개념만을 소개한다.
좀더 데이터 모델링의 자세한 사항은 아래 링크에서 시작해볼 수 있다.

\url{http://en.wikipedia.org/wiki/Relational_model}

한 사람의 친구를 단순히 몇명인지 세는 대신에 트위터 스파이더 응용프로그램으로 모든 관계 리스트를 가지고서 특정한 계정에
팔로잉하는 모든 사람을 찾을 수 있다.

모든 사람은 팔로잉하는 계정을 많이 가지고 있어서, {\tt 트위터(Twitter)} 테이블에 단순히 하나의 열만을 추가할 수는 없다.
그래서 친구를 짝으로 추적할 수 있는 새로운 테이블을 생성한다. 다음은 그런 테이블을 생성하는 간단한 방식이다.

\beforeverb
\begin{verbatim}
CREATE TABLE Pals (from_friend TEXT, to_friend TEXT)
\end{verbatim}
\afterverb
%

{\tt drchuck}을 팔로잉하는 사람을 마주칠 때마다, 다음 형식의 행을 삽입한다.

\beforeverb
\begin{verbatim}
INSERT INTO Pals (from_friend,to_friend) VALUES ('drchuck', 'lhawthorn')
\end{verbatim}
\afterverb
%

{\tt drchuck} 트위터 피드에서 20명의 친구를 처리하면서, ''drchuck''을 첫 매개변수로 가지는 20개 레코드를 삽입해서
데이터베이스에 많이 중복되는 문자열을 가질 것이다.

문자열 데이터를 중복하는 것은 {\bf 데이터베이스 정규화(database normalization)}의 가장 좋은 사례를 위반한다.
데이터베이스 정규화는 결코 한번 이상 데이터베이스에 동일한 문자열을 놓지 않는다. 
만약 한번 이상 데이터가 필요하다면, 데이터에 대한 숫자 {\bf 키(key)}를 생성하고, 키를 사용하여 실제 데이터를 참조한다.

실무에서, 문자열은 컴퓨터상의 주기억장치나 디스크상의 정수형 자료보다 훨씬 많은 공간을 차지하고 비교나 정렬에 더 많은 처리시간이 소요된다.
수백개의 항목이 있다면, 저장소나 처리 시간은 큰 문제가 되지 않는다. 하지만, 데이터베이스에 수백만명의 사람 정보와 1억건 이상의 링크가 있다면,
가능한 빨리 데이터를 스캔하는 것이 중요하다.

앞선 예제에서 사용된 {\tt Twitter} 테이블 대신에 {\tt People}로 명명된 테이블에 트위커 계정을 저장한다.
{\tt People} 테이블은 트위터 사용자의 행과 관련된 숫자키를 저장할 수 있는 추가 열(column)이 있다.
SQLite는 데이터 열의 특별 형식({\tt INTEGER PRIMARY KEY})을 이용하여 테이블에 삽입할 임의의 열에 대해서 자동적으로 키값을 추가하는 기능이 있다.

다음과 같이 추가적인 {\tt id} 열을 가진 {\tt People} 테이블을 생성할 수 있다.

\beforeverb
\begin{verbatim}
CREATE TABLE People 
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)
\end{verbatim}
\afterverb
%

{\tt People} 테이블의 각 행에서 친구 숫자를 더 이상 유지하고 있지 않음을 주목하세요.
{\tt id} 열의 형식으로 {\tt INTEGER PRIMARY KEY} 선택할 때, SQLite가 이 행을 맡아서 
사용자가 삽입하는 각 항에 자동으로 유일한 숫자 키를 할당하도록 나타낸다.
{\tt UNIQUE} 키워드를 추가해서 {\tt name}에 동일한 값을 가진 두 행이 SQLite가 삽입하지 못하도록 나타낸다.

위에 {\tt Pals} 테이블을 생성하는 대신에 데이터베이스에 \verb"from_id", \verb"to_id" 두 정수 열을 지니고 
\verb"from_id"과 \verb"to_id"의 \emph{조합}은 테이블에 유일하다는 제약사항을 가진 {\tt Follows} 테이블을 생성한다.(즉, 중복된 행을 삽입할 수 없다.)

\beforeverb
\begin{verbatim}
CREATE TABLE Follows 
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id) )
\end{verbatim}
\afterverb
%

테이블에 {\tt UNIQUE}절을 추가할 때, 레코드를 삽입할 때 데이터베이스에서 지켜야하는 규칙의 집합을 의사소통하는 것이다.
잠시 후에 보겠지만, 프로그램상에 편리하게 이러한 규칙을 생성한다.
이 규칙은 실수를 방지하게 하고 코드를 작성을 간결하게 한다.

본질적으로 {\tt Follows} 테이블을 생성할 때, ''관계(relationship)''를 모델링하여 한 사람이 다른 사람을 ''팔로우(follow)''하고
이것을 (a) 사람이 연결되어 있고, (b) 관계을 방향성이 나타나도록 숫자 짝을 지어 표현한다.  

\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/twitter.eps}}
\afterfig

\section{다중 테이블을 가지고 프로그래밍}
두개의 테이블, 주키(primary key)와 위에 설명된 참조 키를 사용하여 트위터 스파이더링 프로그램을 다시 작성한다.
다음에 프로그램의 새로운 버젼 코드가 있다.

\beforeverb
\begin{verbatim}
import urllib
import twurl
import json
import sqlite3

TWITTER_URL = 'https://api.twitter.com/1.1/friends/list.json'

conn = sqlite3.connect('friends.sqlitesqlite3')
cur = conn.cursor()

cur.execute('''CREATE TABLE IF NOT EXISTS People 
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Follows 
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))''')

while True:
    acct = raw_input('Enter a Twitter account, or quit: ')
    if ( acct == 'quit' ) : break
    if ( len(acct) < 1 ) :
        cur.execute('''SELECT id, name FROM People 
            WHERE retrieved = 0 LIMIT 1''')
        try:
            (id, acct) = cur.fetchone()
        except:
            print 'No unretrieved Twitter accounts found'
            continue
    else:
        cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1', 
            (acct, ) )
        try:
            id = cur.fetchone()[0]
        except:
            cur.execute('''INSERT OR IGNORE INTO People (name, retrieved) 
                VALUES ( ?, 0)''', ( acct, ) )
            conn.commit()
            if cur.rowcount != 1 : 
                print 'Error inserting account:',acct
                continue
            id = cur.lastrowid

    url = twurl.augment(TWITTER_URL, 
       {'screen_name': acct, 'count': '20'} )
    print 'Retrieving account', acct
    connection = urllib.urlopen(url)
    data = connection.read()
    headers = connection.info().dict
    print 'Remaining', headers['x-rate-limit-remaining']

    js = json.loads(data)
    # print json.dumps(js, indent=4)

    cur.execute('UPDATE People SET retrieved=1 WHERE name = ?', (acct, ) )

    countnew = 0
    countold = 0
    for u in js['users'] :
        friend = u['screen_name']
        print friend
        cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1', 
            (friend, ) )
        try:
            friend_id = cur.fetchone()[0]
            countold = countold + 1
        except:
            cur.execute('''INSERT OR IGNORE INTO People (name, retrieved) 
                VALUES ( ?, 0)''', ( friend, ) )
            conn.commit()
            if cur.rowcount != 1 :
                print 'Error inserting account:',friend
                continue
            friend_id = cur.lastrowid
            countnew = countnew + 1
        cur.execute('''INSERT OR IGNORE INTO Follows (from_id, to_id) 
            VALUES (?, ?)''', (id, friend_id) )
    print 'New accounts=',countnew,' revisited=',countold
    conn.commit()

cur.close()
\end{verbatim}
\afterverb
%

프로그램이 다소 복잡해보입니다. 하지만, 테이블을 연결하기 위해서 정수형 키를 사용하는 패턴을 보여준다.
기본적인 패턴은 다음과 같다.

\begin{enumerate}

\item 주 키와 제약 사항을 가진 테이블을 생성한다.

\item 사람(즉, 계정 이름)에 대한 논리 키가 필요할 때 사람에 대한 {\tt id} 값이 필요하다.
사람 정보가 이미 {\tt People} 테이블에 존재하는지에 따라,
(1) {\tt People} 테이블의 사람을 찾아서 그 사람에 대한 {\tt id} 값을 가져오거나,
(2) 사람을 {\tt People} 테이블에 추가하고 신규로 추가된 행의 {\tt id} 값을 가져온다.

\item ''팔로우(follow)'' 관계를 잡아내는 행을 추가한다.

\end{enumerate}

이들 각각을 순서대로 다룰 것이다.

\subsection{ 데이터베이스 테이블의 제약사항}

As we design our table structures, we can tell the database system 
that we would like it to enforce a few rules on us.   These rules
help us from making mistakes and introducing incorrect data into 
out tables.   When we create our tables:

\beforeverb
\begin{verbatim}
cur.execute('''CREATE TABLE IF NOT EXISTS People 
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Follows 
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))''')
\end{verbatim}
\afterverb
%
We indicate that the {\tt name} column in the {\tt People} table must be
{\tt UNIQUE}.   We also indicate that the combination of the two numbers
in each row of the {\tt Follows} table must be unique.  These constraints
keep us from making mistakes such as adding the same relationship more than
once.

We can take advantage of these constraints in the following code:

\beforeverb
\begin{verbatim}
cur.execute('''INSERT OR IGNORE INTO People (name, retrieved) 
    VALUES ( ?, 0)''', ( friend, ) )
\end{verbatim}
\afterverb
%
We add the {\tt OR IGNORE} clause to our {\tt INSERT} statement to indicate
that if this particular {\tt INSERT} would cause a violation of the
``{\tt name} must be unique'' rule, the database system is allowed to ignore the 
{\tt INSERT}.  We are using the database constraint as a safety net
to make sure we don't inadvertently do something incorrect.

Similarly, the following code ensures that we don't add the 
exact same {\tt Follows} relationship twice.

\beforeverb
\begin{verbatim}
cur.execute('''INSERT OR IGNORE INTO Follows 
    (from_id, to_id) VALUES (?, ?)''', (id, friend_id) )
\end{verbatim}
\afterverb
%
Again we simply tell the database to ignore our attempted 
{\tt INSERT} if it would violate the uniqueness constraint
that we specified for the {\tt Follows} rows.

\subsection{Retrieve and/or insert a record}

When we prompt the user for a Twitter account, if the account 
exists, we must look up its {\tt id} value.  If the account
does not yet exist in the {\tt People} table, we must insert 
the record and get the {\tt id} value from the inserted
row.

This is a very common pattern and is done twice in the program above.
This code shows how we look up the {\tt id} for a 
friend's account when we have extracted a \verb"screen_name"
from a {\tt user} node in the retrieved Twitter JSON.

Since over time it will be increasingly likely that the account
will already be in the database, we first check to see if the
{\tt People} record exists using a {\tt SELECT} statement.

If all goes well\footnote{In general, when a sentence starts 
with ``if all goes well'' you will find that the code needs
to use try/except.} inside the {\tt try} section, we retrieve the
record using {\tt fetchone()} and then retrieve the
first (and only) element of the returned tuple and store it in 
\verb"friend_id".

If the {\tt SELECT} fails, the {\tt fetchone()[0]} code will fail
and control will transfer into the {\tt except} section.

\beforeverb
\begin{verbatim}
        friend = u['screen_name']
        cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1',
            (friend, ) )
        try:
            friend_id = cur.fetchone()[0]
            countold = countold + 1
        except:
            cur.execute('''INSERT OR IGNORE INTO People (name, retrieved) 
                VALUES ( ?, 0)''', ( friend, ) )
            conn.commit()
            if cur.rowcount != 1 :
                print 'Error inserting account:',friend
                continue
            friend_id = cur.lastrowid
            countnew = countnew + 1
\end{verbatim}
\afterverb
%
If we end up in the {\tt except} code, it simply means that the row
was not found so we must insert the row.  We use {\tt INSERT OR 
IGNORE} just to avoid errors and then call {\tt commit()} to 
force the database to really be updated.  After the write is done, we can 
check the {\tt cur.rowcount} to see how many rows were affected.  Since
we are attempting to insert a single row, if the number of 
affected rows is something other than one, it is an error.  

If the {\tt INSERT} is successful, we can look at {\tt cur.lastrowid} 
to find out what value the database assigned to the {\tt id} column in 
our newly created row.

\subsection{Storing the friend relationship}

Once we know the key value for both the Twitter user
and the friend in the JSON, it is a simple matter to insert
the two numbers into the {\tt Follows} table
with the following code:

\beforeverb
\begin{verbatim}
cur.execute('INSERT OR IGNORE INTO Follows (from_id, to_id) VALUES (?, ?)',
    (id, friend_id) )
\end{verbatim}
\afterverb
%
Notice that we let the database take care of keeping us from ``double-inserting''
a relationship by creating the table with a uniqueness constraint and then
adding {\tt OR IGNORE} to our {\tt INSERT} statement.

Here is a sample execution of this program:

\beforeverb
\begin{verbatim}
Enter a Twitter account, or quit: 
No unretrieved Twitter accounts found
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit: 
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: 
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
\end{verbatim}
\afterverb
%
We started with the {\tt drchuck} account and then let the program
automatically pick the next two accounts to retrieve and add to 
our database.

The following is the first few rows in the {\tt People} 
and {\tt Follows} tables after this run is completed:

\beforeverb
\begin{verbatim}
People:
(1, u'drchuck', 1)
(2, u'opencontent', 1)
(3, u'lhawthorn', 1)
(4, u'steve_coppin', 0)
(5, u'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
\end{verbatim}
\afterverb
%
You can see the {\tt id}, {\tt name}, and {\tt visited} fields in the 
{\tt People} table and you see the numbers of both ends of 
the relationship {\tt Follows} table.   
In the {\tt People} table, we can see that the first three people
have been visited and their data has been retrieved.
The data in the {\tt Follows} table indicates that
{\tt drchuck} (user 1) is a friend to all of the people shown in the first
five rows.  This makes sense because
the first data we retrieved and stored was the Twitter friends of
{\tt drchuck}.  If you were to print more rows from the {\tt Follows} table,
you would see the friends of user two and three as well.

\section{Three kinds of keys}

Now that we have started building a data model putting our
data into multiple linked tables, and linking the rows in those
tables using {\bf keys}, we need to look at some terminology 
around keys.  There are generally three kinds of keys used 
in a database model.

\begin{itemize}

\item A {\bf logical key} is a key that the ``real world'' might use
to look up a row.   In our example data model, the {\tt name}
field is a logical key.  It is the screen name for the user 
and we indeed look up a user's row several times in the program
using the {\tt name} field.  You will often find that it makes
sense to add a {\tt UNIQUE} constraint to a logical key.  Since the 
logical key is how we look up a row from the outside world, it makes
little sense to allow multiple rows with the same value in the table.

\item A {\bf primary key} is usually a number that is assigned
automatically by the database.  It generally has no meaning outside
the program and is only used to link rows from different tables
together.  When we want to look up a row in a table, usually 
searching for the row using the primary key is the fastest 
way to find a row.  Since primary keys are integer numbers, they 
take up very little storage and can be compared or sorted very quickly.
In our data model, the {\tt id} field is an example of a primary key.

\item A {\bf foreign key} is usually a number that points to the primary key
of an associated row in a different table.  An example of a foreign
key in our data model is the \verb"from_id".  

\end{itemize}

We are using a
naming convention of always calling the primary key field name
{\tt id} and appending the suffix \verb"_id" to any field name
that is a foreign key.


\section{Using JOIN to retrieve data}

Now that we have followed the rules of database normalization
and have data separated into two tables, linked together using
primary and foreign keys, we need to be able to build a 
{\tt SELECT} that re-assembles the data across the tables.

SQL uses the {\tt JOIN} clause to re-connect these tables.  
In the {\tt JOIN} clause you specify the fields that are used 
to re-connect the rows between the tables.

The following is an example of a {\tt SELECT} with a 
{\tt JOIN} clause:

\beforeverb
\begin{verbatim}
SELECT * FROM Follows JOIN People 
    ON Follows.from_id = People.id WHERE People.id = 1
\end{verbatim}
\afterverb
%
The {\tt JOIN} clause indicates that the fields we are selecting
cross both the {\tt Follows} and {\tt People} tables.  The {\tt ON}
clause indicates how the two tables are to be joined.   Take the rows
from {\tt Follows} and append the row from {\tt People} where the
field \verb"from_id" in {\tt Follows} is the same the {\tt id} value
in the {\tt People} table.

\beforefig
\centerline{\includegraphics[height=2.50in]{figs2/join.eps}}
\afterfig

The result of the JOIN is to create extra-long ``meta-rows'' which have both 
the fields from {\tt People} and the matching fields from {\tt Follows}.
Where there is more than one match between the {\tt id} field from {\tt People}
and the \verb"from_id" from {\tt People}, then JOIN creates a meta-row 
for \emph{each} of the matching pairs of rows, duplicating data as needed.

The following code demonstrates the data that we will have in the 
database after the multi-table Twitter spider program (above) has
been run several times.

\beforeverb
\begin{verbatim}
import sqlite3

conn = sqlite3.connect('spider.sqlite3')
cur = conn.cursor()

cur.execute('SELECT * FROM People')
count = 0
print 'People:'
for row in cur :
   if count < 5: print row
   count = count + 1
print count, 'rows.'

cur.execute('SELECT * FROM Follows')
count = 0
print 'Follows:'
for row in cur :
   if count < 5: print row
   count = count + 1
print count, 'rows.'

cur.execute('''SELECT * FROM Follows JOIN People 
    ON Follows.from_id = People.id WHERE People.id = 2''')
count = 0
print 'Connections for id=2:'
for row in cur :
   if count < 5: print row
   count = count + 1
print count, 'rows.'

cur.close()
\end{verbatim}
\afterverb
%
In this program, we first dump out the {\tt People}
and {\tt Follows} and then dump out a subset of the
data in the tables joined together.

Here is the output of the program:

\beforeverb
\begin{verbatim}
python twjoin.py 
People:
(1, u'drchuck', 1)
(2, u'opencontent', 1)
(3, u'lhawthorn', 1)
(4, u'steve_coppin', 0)
(5, u'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
Connections for id=2:
(2, 1, 1, u'drchuck', 1)
(2, 28, 28, u'cnxorg', 0)
(2, 30, 30, u'kthanos', 0)
(2, 102, 102, u'SomethingGirl', 0)
(2, 103, 103, u'ja_Pac', 0)
20 rows.
\end{verbatim}
\afterverb
%
You see the columns from the {\tt People} and {\tt Follows} tables and the last
set of rows is the result of the {\tt SELECT} with the {\tt JOIN} clause.

In the last select, we are looking for accounts that are friends of 
``opencontent'' (i.e. {\tt People.id=2}).

In each of the ``meta-rows'' in the last select, the first two columns are
from the {\tt Follows}
table followed by columns three through five from the {\tt People} table.  You can also
see that the second column (\verb"Follows.to_id") matches the third column
({\tt People.id}) in each of the joined-up ``meta-rows''.

\section{Summary}

This chapter has covered a lot of ground to give you an overview of the basics
of using a database in Python.   It is more complicated to write the code to use 
a database to store data than Python dictionaries or flat files so there is 
little reason to use a database unless your application truly needs the capabilities
of a database.  The situations where a database can be quite useful are: 
(1) when your application needs to make small many random updates within a large data set,
(2) when your data is so large it cannot fit in a dictionary and you need to 
look up information repeatedly, or
(3) you have a long-running process that you want to be able to stop 
and restart and retain the data from one run to the next.

You can build a simple database with a single table to suit many application 
needs, but most problems will require several tables and links/relationships
between rows in different tables.   When you start making links between 
tables, it is important to do some thoughtful design and follow the 
rules of database normalization to make the best use of the database's
capabilities.  Since the primary motivation for using a database
is that you have a large amount of data to deal with, it is important
to model your data efficiently so your programs run as fast as possible.

\section{Debugging}

One common pattern when you are developing a Python program to connect to
an SQLite database will be to run a Python program and check the
results using the SQLite Database Browser.  The browser allows you 
to quickly check to see if your program is working properly.

You must be careful because SQLite takes care to keep two programs
from changing the same data at the same time.   For example, if
you open a database in the browser and make a change to the database
and have not yet pressed the ``save'' button in the browser, the 
browser ``locks'' the database file and keeping any other program
from accessing the file.  In particular, your Python program
will not be able to access the file if it is locked.

So a solution is to make sure to either close the database browser 
or use the {\bf File} menu to close the database in the browser
before you attempt to access the database from Python to avoid
the problem of your Python code failing because the database is
locked.

\section{Glossary}

\begin{description}

\item[attribute:] One of the values within a tuple.  More commonly
called a ``column'' or ``field''.
\index{attribute}

\item[constraint:] 
When we tell the database to enforce a rule on a field or a row
in a table.  A common constraint is to insist that there can be no
duplicate values in a particular field (i.e. all the values must be unique).
\index{constraint}

\item[cursor:] A cursor allows you to execute SQL commands in a database
and retrieve data from the database.  A cursor is similar to 
a socket or file handle for network connections and files respectively.
\index{cursor}

\item[database browser:] 
A piece of software that allows you to directly connect to a database 
and manipulate the database directly without writing a program.
\index{database browser}

\item[foreign key:] A numeric key that points to the primary key of 
a row in another table.  Foreign keys establish relationships between rows
stored in different tables.
\index{foreign key}

\item[index:] Additional data that the database software maintains as rows
are inserted into a table designed to make lookups very fast.
\index{index}

\item[logical key:] A key that the ``outside world'' uses to look up a particular
row.  For example in a table of user accounts, a person's e-mail address
might be a good candidate as the logical key for the user's data. 
\index{logical key}

\item[normalization:] Designing a data model so that no data
is replicated.  We store each item of data at one place in the database
and reference it elsewhere using a foreign key.
\index{normalization}
\index{database normalization}

\item[primary key:] A numeric key assigned to each row that is used to 
refer to one row in a table from another table.  Often the database
is configured to automatically assign primary keys as rows are inserted.
\index{primary key}

\item[relation:] An area within a database that contains tuples and 
attributes.  More typically called a ``table''.
\index{relation}

\item[tuple:] A single entry in a database table that is a set 
of attributes.  More typically called ``row''.
\index{tuple}

\end{description}

