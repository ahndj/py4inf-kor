% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved
% 한국어 번역 : 이광춘, 한정수
\chapter{변수, 표현식, 문장(Statement)}

\section{값(Value)과 자료형(Type)}
\index{값(value)}
\index{자료형(type)}
\index{문자열(string)}

{\bf 값(Value)}은 문자와 숫자처럼 프로그램이 다루는 가장 기본이 되는 단위이다. 
지금까지 살펴본 값은 {\tt 1}, {\tt 2} 그리고 \verb"'Hello,World!'" 이다.

상기 값은 다른 {\bf 자료형(Type)}에 속하는데, {\tt 2}는 정수, \verb" 'Hello,World!'" 는 
{\bf 문자열(String)}에 속하는데, 문자(Letter)를 일련의 열(sequence)의 형태로 되어 있어서 문자열이라고 부른다. 
인용부호에 감싸여 있어서, 여러분과 인터프리터는 문자열을 식별할 수 있다. 

{\tt print } 문은 정수에도 사용할 수 있다. {\tt python} 명령어를 실행하여 인터프리터를 구동시키자.

\index{quotation mark}

\beforeverb
\begin{verbatim}
python
>>> print 4
4
\end{verbatim}
\afterverb
%
값이 어떤 형인지 확신을 못한다면, 인터프리터가 알려준다.

\beforeverb
\begin{verbatim}
>>> type('Hello, World!')
<type 'str'>
>>> type(17)
<type 'int'>
\end{verbatim}
\afterverb
%

놀랍지도 않게, strings은 {\tt str} 형식이고, 정수는 {\tt int} 형식이다. 
다소 명백하지는 않지만, 소숫점을 가진 숫자는 {\tt float} 형식이다. 왜냐하면 이들 숫자가 {\bf 부동소수점} 형식으로 표현되기 때문이다.

\index{자료형 (type)}
\index{문자열 자료형 (string type)}
\index{자료형(type)!문자열 자료형 (str)}
\index{정수형 (int type)}
\index{자료형(type)!int (정수형)}
\index{부동소수점형 (float type)}
\index{자료형(type)!float (부동소수점형)}

\beforeverb
\begin{verbatim}
>>> type(3.2)
<type 'float'>
\end{verbatim}
\afterverb
%

\verb"'17'", \verb"'3.2'" 같은 값은 어떨가? 숫자처럼 보이지만 문자열처럼 인용부호에 감싸여 있다.

\index{인용 부호 (quotation mark)}

\beforeverb
\begin{verbatim}
>>> type('17')
<type 'str'>
>>> type('3.2')
<type 'str'>
\end{verbatim}
\afterverb
%

\verb"'17'", \verb"'3.2'" 은 문자열이다.

{\tt 1,000,000} 처럼 아주 큰 정수를 입력할 때, 세자리 숫자마다 콤마(,)를 사용하고 싶을 것이다. 하지만, 파이썬에서 적법하게 정수를 표현하는 것은 아니지만 문법적으로는 적합하다.

\beforeverb
\begin{verbatim}
>>> print 1,000,000
1 0 0
\end{verbatim}
\afterverb
%

하지만, 파이썬 실행 결과는 우리가 기대했던 것이 아니다. 파이썬에서는 {\tt 1,000,000} 을 콤마(',')로 구분된 정수로 인식한다. 따라서 사이 사이 공백을 넣어 출력했다.

\index{의미론적 오류 (semantic error)} % \index{semantic error}
\index{error (오류)!semantic (의미론)} % \index{error!semantic}
\index{error message (오류 메시지)}

이 사례가 여러분이 처음 경험하게 되는 의미론적 오류(semantic error)다. 
코드가 에러 메세지 없이 실행이되지만, ''올바른(right)'' 작동을 하는 것은 아니다.

\section{변수(Variable)}
\index{변수 (variable)} % \index{variable}
\index{대입문 (assignment statement)} %\index{assignment statement}
\index{statement (문장)!assignment (대입)} % \index{statement!assignment}

프로그래밍 언어의 가장 강력한 기능 중의 하나는 변수를 다룰 수 있는 능력이다. {\bf 변수(Variable)}는 값을 참조하는 이름이다.

{\bf 대입문(Assignment statement)}는 새로운 변수를 생성하고 값을 변수에 대입한다.

\beforeverb
\begin{verbatim}
>>> message = 'And now for something completely different'
>>> n = 17
>>> pi = 3.1415926535897931
\end{verbatim}
\afterverb
%

상기 예제는 세가지 대입 사례를 보여준다. 첫 번째 대입 예제는 {\tt message} 변수에 문자열을 대입한다. 두 번째 예제는 변수 {\tt n}에 정수 {\tt 17}을 대입한다. 세 번째 예제는 {\tt pi}변수에 $\pi$ 근사값을 대입한다.

변수 값을 출력하기 위해서 {\tt print}문을 사용한다.

\beforeverb
\begin{verbatim}
>>> print n
17
>>> print pi
3.14159265359
\end{verbatim}
\afterverb
%

변수 자료형(type)은 변수가 참조하는 값의 자료형이다.

\beforeverb
\begin{verbatim}
>>> type(message)
<type 'str'>
>>> type(n)
<type 'int'>
>>> type(pi)
<type 'float'>
\end{verbatim}
\afterverb
%

\section{변수명(Variable name)과 예약어(keywords)}
\index{keyword (예약어)} % \index{keyword}

대체로 프로그래머는 의미있는 변수명을 고른다. 프로그래머는 변수가 사용되는 것에 대해 문서화도 한다.

변수명은 임의로 길 수 있다. 변수명은 문자와 숫자를 포함할 수 있지만, 문자로 변수명을 시작해야 한다. 첫 변수명을 대문자로 사용해도 되지만 소문자로 변수명을 시작하는 것도 좋은 생각이다. (후에 왜 그런지 보게 될 것이다.)

변수명에 밑줄(underscore character, \verb"_")이 들어갈 수 있다. 종종 \verb"my_name" 혹은 \verb"airspeed_of_unladen_swallow" 처럼 밑줄은 여러 단어와 함께 사용된다.
변수명을 밑줄로 시작해서 작성할 수 있지만, 다른 사용자가 사용할 라이브러리를 작성하는 경우가 아니라면, 일반적으로 밑줄로 시작하는 변수명은 피한다.

\index{밑줄 (underscore character)} % \index{underscore character}

변수명을 적합하게 작성하지 못하다면, 구문 오류가 발생한다.

\beforeverb
\begin{verbatim}
>>> 76trombones = 'big parade'
SyntaxError: invalid syntax
>>> more@ = 1000000
SyntaxError: invalid syntax
>>> class = 'Advanced Theoretical Zymurgy'
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%

{\tt 76trombones} 변수명은 문자로 시작하지 않아서 적합하지 않다. 
{\tt more@}은 특수 문자 ({\tt @})를 변수명에 포함해서 적합하지 않다. 
하지만, {\tt class} 변수명은 뭐가 잘못된 것일까?

구문 오류 이유는 {\tt class}가 파이썬의 예약어 중의 하나라고 밝혀졌다. 
인터프리터가 예약어를 사용하여 프로그램 구조를 파악하기 위해서 사용하지만, 변수명으로는 사용할 수 없다.

\index{예약어 (keyword)}
%\index{keyword}

파이썬에는 31개 키워드\footnote{Python 3.0 에서 {\tt exec} 은 더 이상 예약어가 아니지만, {\tt nonlocal} 은 여전히 예약어다.}가 예약어로 이미 사용중에 있다.

\beforeverb
\begin{verbatim}
and       del       from      not       while    
as        elif      global    or        with     
assert    else      if        pass      yield    
break     except    import    print              
class     exec      in        raise              
continue  finally   is        return             
def       for       lambda    try
\end{verbatim}
\afterverb
%

상기 예약어 목록을 주머니에 넣고 잘 가지고 다니고 싶을 것이다. 
만약 인터프리터가 변수명 중 하나에 대해 불평을 하지만 이유를 모르는 경우, 예약어 목록에 변수명이 있는지 확인해 보세요.

\section{문장(Statement)}

{\bf 문장(statement)}은 파이썬 인터프리터가 실행하는 코드 단위다. 지금까지 print, assignment 두 종류의 문장을 살펴봤습니다.

\index{문장 (statement)}
\index{인터랙티브 모드 (interactive mode)}
\index{스크립트 모드 (script mode)}
%\index{statement}
%\index{interactive mode}
%\index{script mode}

인터랙트브 모드에서 문장을 입력하면, 인터프리터는 문장을 실행하고, 만약 출력할 것이 있다면 결과를 화면에 출력합니다.

스크립트는 보통 여러줄의 문장으로 구성됩니다. 하나 이상의 문장이 있다면, 스트테이트먼트가 실행되며서 결과가 한번에 하나씩 나타납니다.

예를 들어, 다음의 스크립트를 생각해 봅시다.

\beforeverb
\begin{verbatim}
print 1
x = 2
print x
\end{verbatim}
\afterverb
%

상기 스크립트는 다음 결과를 출력합니다.

\beforeverb
\begin{verbatim}
1
2
\end{verbatim}
\afterverb
%

대입 문장{\tt (x=2)}은 결과를 출력하지 않습니다.

\section{연산자(Operator)와 피연산자(Operands)}
\index{연산자 (operator), 산술(arithmetic)}
\index{산술 연산자 (arithmetic operator)}
\index{피연산자 (operand)}
\index{표현식 (expression)}

%\index{operator, arithmetic}
%\index{arithmetic operator}
%\index{operand}
%\index{expression}

{\bf 연산자(Operators)}는 덧셈, 곱셈 같은 계산(Computation)을 표현하는 특별한 기호입니다. 연산가자 적용되는 값을 {\bf 피연산자(operands)}라고 합니다.

다음의 예제에서 보듯이, {\tt +}, {\tt -}, {\tt *}, {\tt /}, {\tt **} 연산자는 덧셈, 뺄셈, 곱셈, 나눗셈, 지수승을 수행합니다.

\beforeverb
\begin{verbatim}
20+32   hour-1   hour*60+minute   minute/60   5**2   (5+9)*(15-7)
\end{verbatim}
\afterverb
%
나눗셈 연산자는 여러분이 기대하는 것을 수행하지 않을 수도 있습니다.

\beforeverb
\begin{verbatim}
>>> minute = 59
>>> minute/60
0
\end{verbatim}
\afterverb
%

{\tt minute} 값은 59, 보통 59를 60으로 나누면 0 대신에 0.98333 입니다. 이런 차이가 발생하는 이유는 파이썬이 {\bf 소수점 이하 버림 나눗셈}\footnote{파이썬 3.0 에서 이 나눗셈 값은 {\tt 소수점}입니다. 파이썬 3.0 에 도입된 새로운 연산자{\tt //}는 정수형 나눗셈을 수행합니다.}을 하기 때문입니다.

\index{파이썬 3.0 (Python 3.0)}
\index{버림 나눗셈 (floor division)}
\index{부동 소수점 나눗셈 (floating-point division)}
\index{나눗셈 (division)!절사 (floor)}
\index{나눗셈 (division)!부동 소수점 (floating-point)}
%\index{Python 3.0}
%\index{floor division}
%\index{floating-point division}
%\index{division!floor}
%\index{division!floating-point}

두 개의 피연산자가 정수이면, 결과도 정수입니다. 부동 소수점 나눗셈은 소수점 이하를 절사합니다.
그래서 예제에서 소수점 이하 잘라버려 0 이 됩니다.

만약 두 개의 피연산자 중 하나가 부동 소수점 수이면, 파이썬은 부동 소수점 나눗셈을 수행하고 결과는 {\tt 부동 소수점형} 값이 된다.

\beforeverb
\begin{verbatim}
>>> minute/60.0
0.98333333333333328
\end{verbatim}
\afterverb

\section{표현식(Expression)}

{\bf 표현식 (expression)}은 값, 변수, 연산자 조합니다. 값은 자체로 표현식이고, 변수도 동일하다. 따라서 다음 표현식은 모두 적합하다. 
(변수 {\tt x}는 사전에 어떤 값이 대입되었다고 가정한다.)

%\index{expression}
%\index{evaluate}
\index{표현식 (expression)}
\index{평가 (evaluate)}

\beforeverb
\begin{verbatim}
17
x
x + 17
\end{verbatim}
\afterverb
%

인터랙티브 모드에서 표현식을 입력하면, 인터프리터는 표현식을 {\bf 평가(evaluate)}하고 값을 표시한다.

\beforeverb
\begin{verbatim}
>>> 1 + 1
2
\end{verbatim}
\afterverb
%

하지만, 스크립트에서는 표현식 자체로 어떠한 것도 수행하지는 않는다. 초심자에게 혼란스러운 점이다.

\begin{ex}

파이썬 인터프리터에 다음 문장을 입력하고 결과를 보세요.

\beforeverb
\begin{verbatim}
5
x = 5
x + 1
\end{verbatim}
\afterverb
%
\end{ex}


\section{연산자 적용 우선순위 (Order of Operations)}
\index{연산자 적용 우선순위 (order of operations)}
\index{우선순위 규칙 (rules of precedence)}
\index{PEMDAS}
%\index{order of operations}
%\index{rules of precedence}
%\index{PEMDAS}

1개 이상의 연산자가 표현식에 등장할 때, 
연산자 평가 순서는 {\bf  우선순위 규칙(rules of precedence)}에 따른다. 
수학 연산자에 대해서 파이썬은 수학적 관례를 동일하게 따른다. 영어 두문어 {\bf PEMDAS}는 기억하기 좋은 방식이다.

\index{괄호 (parentheses)!최우선 우선순위 (overriding precedence)}
%\index{parentheses!overriding precedence}

\begin{itemize}

\item {\bf 괄호(Parentheses)}는 가장 높은 순위를 가지고 여러분이 원하는 순위에 맞춰 실행할 때 사용한다. 
괄호내의 식이 먼저 실행되기 때문에 {\tt 2 * (3-1)} 은 4가 정답이고, {\tt (1+1)**(5-2)}는 8이다. 
괄호를 사용하여 표현식을 좀더 읽기 쉽게 하려고 사용하기도 한다. 
{\tt (minute * 100) / 60} 는 실행순서가 결과값에 영향을 주지 않지만 가독성이 상대적으로 더 좋다.

\item {\bf 지수승(Exponentiation)}이 다음으로 높은 우선순위를 가진다. 
그래서 {\tt 2**1+1}는 4가 아니라 3이고, {\tt 3*1**3}는 27이 아니고 3이다. 

\item {\bf 곱셈(Multiplication)과 나눗셈(Division)}은 동일한 우선순위를 가지지만, 덧셈(Addition), 뺄셈(Substraction)보다 높은 우선 순위를 가진다. 덧셈과 뺄샘은 같은 실행 우선순위를 갖는다. {\tt 2*3-1}는 4가 아니고 5이고, {\tt 6+4/2}는 5가 아니라 8이다.

\item 같은 실행 순위를 갖는 연산자는 왼쪽에서부터 오른쪽으로 실행된다. 
{\tt 5-3-1} 표현식은 3이 아니고 1이다. 왜냐하면 {\tt 5-3}이 먼저 실행되고 나서 {\tt 2}에서 {\tt 1}을 빼기 때문이다.

\end{itemize}

여러분이 의도한 순서대로 연산이 수행될 수 있도록, 좀 의심스러운 경우는 항상 괄호를 사용한다.

\section{나머지 연산자 (Modulus Operator)}

%\index{modulus operator}
%\index{operator!modulus}
\index{나머지 연산자 (modulus operator)}
\index{연산자 (operator)!나머지 (modulus)}

{\bf 나머지 연산자(modulus operator)}는 정수에 사용하며, 첫번째 피연산자를 두번째 피연산자가 나눌 때 나머지 값이 생성된다. 
파이썬에서 나머지 연산자는 퍼센트 기호(\verb"%")다. 구문은 다른 연산자와 동일하다.

\beforeverb
\begin{verbatim}
>>> quotient = 7 / 3
>>> print quotient
2
>>> remainder = 7 % 3
>>> print remainder
1
\end{verbatim}
\afterverb
%

7을 3으로 나누면 몫이 2가 되고 나머지가 1이 된다.

나머지 연산자가 놀랍도록 유용다다. 예를 들어 한 숫자를 다른 숫자로 나눌 수 있는지 없는지를 확인할 수도 있다. 
{\tt x \% y} 값이 0 이라면, {\tt x}를 {\tt y}로 나눌 수 있다.

%\index{divisibility}
\index{가분성 (divisibility)}

또한, 숫자에서 가장 오른쪽 숫자를 분리하는데도 사용된다. 
예를 들어 {\tt x \% 10} 은 {\tt x}가 10진수인 경우 가장 오른쪽 숫자를 뽑아낼 수 있고, 동일한 방식으로 {\tt x \% 100}은 가장 오른쪽 2개 숫자를 뽑아낼 수도 있다.

\section{문자열 연산자 (String Operator)}
\index{string (문자열)!operation (연산)}
\index{operator (연산자)!string (문자열)}
%\index{string!operation}
%\index{operator!string}

{\tt +} 연산자는 문자열에도 동작하지만, 수학에서 말하는 덧셈은 아니다. 
대신에 문자열 끝과 끝을 붙이는 {\bf 연결(concatenation)} 작업을 수행한다. 예를 들어,

\index{연결 (concatenation)}
%\index{concatenation}

\beforeverb
\begin{verbatim}
>>> first = 10
>>> second = 15
>>> print first+second
25
>>> first = '100'
>>> second = '150'
>>> print first + second
100150
\end{verbatim}
\afterverb
%

상기 프로그램 출력은 {\tt 100150} 이다.

\section{사용자에게서 입력값 받기}

\index{키보드 입력 (keyboard input)}
%\index{keyboard input}

때때로 키보드를 통해서 사용자로부터 변수에 대한 값을 입력받고 싶을 때가 있다. 
키보드\footnote{파이썬 3.0에서 입력 함수는 {\tt input}으로 명명되었다.}로부터 입력값을 받는 \verb"raw_input" 이라는 내장(built-in) 함수를 파이썬에서 제공한다. 입력 함수가 호출되면, 파이썬은 실행을 멈추고 사용자가 무언가 입력하기를 기다린다. 
사용자가 {\sf Return (리턴)} 혹은 {\sf Enter (엔터)} 키를 누르게 되면 프로그램이 다시 실행되고, \verb"raw_input"은 사용자가 입력한 것을 문자열로 반환한다.

\index{파이썬 3.0 (Python 3.0)}
\index{raw\_input 함수 (raw\_input function)}
\index{함수 (function)!raw\_input}
%\index{Python 3.0}
%\index{raw\_input function}
%\index{function!raw\_input}

\beforeverb
\begin{verbatim}
>>> input = raw_input()
Some silly stuff
>>> print input
Some silly stuff
\end{verbatim}
\afterverb
%

사용자로부터 입력 받기 전에 프롬프트에서 사용자가 어떤 값을 입력해야 하는지 정보를 제공하는 것도 좋은 생각이다. 
입력을 받기 위해 잠시 멈춰있을 때, 사용자에게 표시되도록 \verb"raw_input" 함수에 문자열을 전달할 수 있다.

\index{프롬프트 (prompt)}
%\index{prompt}

\beforeverb
\begin{verbatim}
>>> name = raw_input('What is your name?\n')
What is your name?
Chuck
>>> print name
Chuck
\end{verbatim}
\afterverb
%

프롬프트의 끝에 \verb"\n" 은 {\bf 개행(newline)}을 의미한다. 개행은 줄을 바꾸게 하는 특수 문자다. 
이런 이유 때문에 사용자 입력이 프롬프트 밑에 출력된다.

\index{개행 (newline)}

만약 사용자가 정수를 입력하기를 바란다면, 
{\tt int()}함수를 사용하여 반환되는 값을 {\tt 정수(int)}로 자료형을 변환한다.

\beforeverb
\begin{verbatim}
>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\n'
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
17
>>> int(speed)
17
>>> int(speed) + 5
22
\end{verbatim}
\afterverb
%

하지만, 사용자가 숫자 문자열이 아닌 다른 것을 입력하게 되면 오류가 발생한다.

\beforeverb
\begin{verbatim}
>>> speed = raw_input(prompt)
What...is the airspeed velocity of an unladen swallow?
What do you mean, an African or a European swallow?
>>> int(speed)
ValueError: invalid literal for int()
\end{verbatim}
\afterverb
%

나중에  이런 종류의 오류룰 어떻게 다루는지 배울 것이다.

\index{값오류 (ValueError)}
\index{예외 (exception)!값오류 (ValueError)}
%\index{ValueError}
%\index{exception!ValueError}


\section{주석}
\index{주석 (comment)}
%\index{comment}

프로그램이 커지고 복잡해짐에 따라 가독성은 떨어진다. 형식 언어(formal language)는 촘촘하고 코드 일부분도 읽기 어렵고 무슨 역할을 왜 수행하는지 이해하기 어렵다.

이런 이유로 프로그램이 무엇을 하는지를 자연어로 프로그램에 노트를 달아두는 것은 좋은 생각이다. 
이런 노트를 {\bf 주석(Comments)}이라고 하고 \verb"#" 기호로 시작한다.

\beforeverb
\begin{verbatim}
# 경과한 시간을 퍼센트로 계산
percentage = (minute * 100) / 60
\end{verbatim}
\afterverb
%
상기 사례의 경우, 주석 자체가 한줄이다. 주석을 프로그램의 맨 뒤에 놓을 수도 있다.

\beforeverb
\begin{verbatim}
percentage = (minute * 100) / 60     # 경과한 시간을 퍼센트로 계산
\end{verbatim}
\afterverb
%

{\tt \#} 뒤의 모든 것은 무시되기 때문에 프로그램에는 아무런 영향이 없다.

명확하지 않은 코드의 기능을 문서화할 때 주석은 가장 유용하게 된다.
프로그램을 읽는 사람이 코드가 \emph{무엇}을 하는지 이해한다고 가정하는 것은 일리가 있다.
\emph{왜} 그런지를 이유를 설명하는 것은 더욱 유용하다.

다음의 주석은 코드와 중복되어 쓸모가 없다.

\beforeverb
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
\afterverb
%

다음의 주석은 코드에 없는 유용한 정보가 있다.

\beforeverb
\begin{verbatim}
v = 5     # velocity in meters/second. 
\end{verbatim}
\afterverb
%
좋은 변수명은 주석을 할 필요를 없게 만들지만, 지나치게 긴 변수명은 읽기 어려운 복잡한 표현식이 될 수 있다. 그래서 상충관계(trade-off)가 존재한다.

\section{연상되는 변수명 만들기}

\index{연상기호 (mnemonic)}
%\index{mnemonic}

변수를 이름 짓는데 단순한 규칙을 지키고 예약어를 피하기만 하다면, 변수이름을 작명할 수 있는 무척이나 많은 경우의 수가 존재한다. 
처음에 이렇게 넓은 선택폭이 오히려 프로그램을 읽는 사람이나 프로그램을 작성하는 사람 모두에게 혼란을 줄 수 있다. 
예를 들어, 다음의 3개 프로그램은 각 프로그램이 달성하려하는 관점에서 동일하지만, 여러분이 읽고 이해하는데는 많은 차이점이 있다.

\beforeverb
\begin{verbatim}
a = 35.0
b = 12.50
c = a * b
print c

hours = 35.0
rate = 12.50
pay = hours * rate
print pay

x1q3z9ahd = 35.0
x1q3z9afd = 12.50
x1q3p9afd = x1q3z9ahd * x1q3z9afd
print x1q3p9afd
\end{verbatim}
\afterverb
%
파이썬 인터프리터는 상기 3개 프로그램을 \emph{정확하게 동일하게} 바라보지만, 
사람은 이들 프로그램을 매우 다르게 보고 이해한다. 
사람은 가장 빨리 두 번째 프로그램의 {\bf 의도}를 알아차린다. 
왜냐하면 각 변수에 무슨 데이터가 저장될지에 관해서, 프로그래머의 {\bf 의도}를 반영하는 변수명을 사용했기 때문이다.

현명하게 선택된 변수명을 \emph{연상기호 변수명("mnemonic variable name")}이라고 한다. 연상되기 좋은 영어 단어 "mnemonic"\footnote{ 
\url{http://en.wikipedia.org/wiki/Mnemonic 참조 바랍니다.}}
은 기억을 돕는다는 뜻이다. 
왜 변수를 생성했는지 기억하기 좋게 하기 위해서 연상하기 좋은 변수명을 선택한다.

매우 훌륭하게 들리고, 연상하기 좋은 변수명을 만드는게 좋은 아이디어 같지만, 
기억하기 좋은 변수명은 초보 프로그래머가 코드를 파싱(parsing)하고 이해하는데 걸림돌이 되기도 한다. 
왜냐하면 31개 밖에 되지 않지만 예약어도 기억하지 못하고,
변수명이 때때로 너무 서술적이라 마치 일반적으로 사용하는 언어처럼 보이고 잘 선택된 변수명처럼 보이지 않기 때문이다.

어떤 데이터를 반복하는 다음 파이썬 코드를 살펴보자. 
곧 반복 루프를 살펴보겠지만, 다음 코드가 무엇을 의미하는지 알기 위해서 퍼즐을 풀어보자.

\beforeverb
\begin{verbatim}
for word in words:
    print word
\end{verbatim}
\afterverb
%
무엇이 일어나고 있는 것일까?
for, word, in 등등 어느 토큰이 예약어일까? 
변수명은 무엇일까? 
파이썬은 기본적으로 단어의 개념을 이해할까? 
초보 프로그래머는 어느 부분 코드가 이 예제와 동일해야만 \emph{하는지} 그리고, 
어느 부분 코드가 프로그래머 선택에 의한 것인지 분간하는데 고생을 한다.

다음의 코드는 위의 코드와 동일하다.

\beforeverb
\begin{verbatim}
for slice in pizza:
    print slice
\end{verbatim}
\afterverb
%
초보 프로그래머가 이 코드를 보고 어떤 부분이 파이썬 예약어이고 어느 부분이 프로그래머가 선택한 변수명인지 알기 쉽다. 
파이썬이 피자와 피자조각에 대한 근본적인 이해가 없고, 피자는 하나 혹은 여러 조각으로 구성된다는 근본적인 사실을 알지 못한다는 것은 자명하다.

하지만, 작성한 프로그램이 데이터를 읽고 데이터에 있는 단어를 찾는다면 {\tt 피자(pizza)}와 {\tt 피자조각(slice)}은 연상하기 좋은 변수명이 아니다. 이것을 변수명으로 선핸하게 되면 프로그램의 의미를 왜곡시킬 수 있다.

좀 시간을 보낸 후에 가장 흔한 예약어에 대해서 알게 될 것이고, 이들 예약어가 어느 순간 여러분에게 눈에 띄게 될 것이다.

{\tt {\bf for} word {\bf in} words{\bf :}\\
\verb"    "{\bf print} word }

파이썬에서 정의된 코드 일부분({\tt for}, {\tt in}, {\tt print}, {\tt :})은 예약어로 굵게 표시되어 있고, 
프로그래머가 생성한 변수명({\tt word}, {\tt words})는 굵게 표시되어 있지 않다. 
대다수 텍스트 편집기는 파이썬 구문을 인지하고 있어서, 
파이썬 예약어와 프로그래머가 작성한 변수를 구분하기 위해서 색깔을 다르게 표시한다. 
잠시 후에 여러분은 파이썬을 읽고 변수와 예약어를 빠르게 구분할 수 있을 것이다.

\section{디버깅(Debugging)}
\index{디버깅 (debugging)}
%\index{debugging}

이 지점에서 여러분이 저지르기 쉬운 구문 오류는 \verb"odd~job", \verb"US$" 같은 특수문자를 포함해서 잘못된 변수명을 생성하는 것과 {\tt class}, {\tt yield}같은 예약어를 변수명으로 사용하는 것이다. 

\index{구문 오류 (syntax error)}
\index{오류 (error)!구문 (syntax)}
%\index{syntax error}
%\index{error!syntax}

변수명에 공백을 넣는다면, 파이썬은 연산자 없는 두 개의 피연산자로 생각한다.

\beforeverb
\begin{verbatim}
>>> bad name = 5
SyntaxError: invalid syntax
\end{verbatim}
\afterverb
%
구문 오류에 대해서, 오류 메세지는 그다지 도움이 되지 못한다. 
가장 흔한 오류 메세지는 {\tt SyntaxError: invalid syntax}, {\tt SyntaxError: invalid token}인데 둘다 그다지 오류에 대한 많은 정보를 주지는 못한다.

\index{오류 메시지 (error message)}
\index{정의 전 사용 (use before def)}
\index{예외 (exception)}
\index{런타임 오류 (runtime error)}
\index{오류 (error)!런타임 (runtime)}
%\index{error message}
%\index{use before def}
%\index{exception}
%\index{runtime error}
%\index{error!runtime}

여러분이 많이 범하는 실행 오류는 정의 전에 사용(''use before def'')하는 것으로 변수에 값을 대입하기 전에 변수를 사용할 경우 발생한다. 여러분이 변수명을 잘못 쓸 때도 발생할 수 있다.

\beforeverb
\begin{verbatim}
>>> principal = 327.68
>>> interest = principle * rate
NameError: name 'principle' is not defined
\end{verbatim}
\afterverb
%
변수명은 대소문자를 구분한다. 그래서, {\tt LaTeX}는 {\tt latex}와 같지 않다.

\index{대소문자 구별 (case-sensitivity), 변수명 (variable names)}
\index{의미론적 오류(semantic error)}
\index{오류 (error)!의미론 (semantic)}
%\index{case-sensitivity, variable names}
%\index{semantic error}
%\index{error!semantic}

이 지점에서 여러분이 범하기 쉬운 의미론적 오류는 연산자 우선 순위일 것이다. 
예를 들어 $\frac{1}{2 \pi}$를 계산하기 위해서 다음과 같이 프로그램을 작성하게 되면 ...


\beforeverb
\begin{verbatim}
>>> 1.0 / 2.0 * pi
\end{verbatim}
\afterverb
%
나눗셈이 먼저 일어나서 $\pi / 2$이 되는데 의도한 것과 같지 않다. 
파이썬으로 하여금 여러분이 작성한 의도를 알게할 수는 없다. 
그래서 이런 경우 오류 메세지는 없지만, 여러분은 잘못된 답을 얻게 된다.

\index{연산자 우선순위 (order of operations)}
%\index{order of operations}


\section{용어 설명}

\begin{description}

\item[대입(assignment):] 변수에 값을 대입하는 문장
\index{대입 (assignment)}
%\index{assignment}

\item[연결(concatenate):] 두 개의 피연산자 끝과 끝을 합치는 것
\index{연결 (concatenation)}
%\index{concatenation}

\item[주석(comment):] 다른 프로그래머나 소스코드를 읽는 다른 사람을 위한 프로그램 정보로 프로그램의 실행에는 아무런 영향이 없다.
\index{주석 (comment)}
%\index{comment}

\item[평가(evaluate):] 하나의 값을 만들도록 연산을 실행함으로써 표현식을 간단히 하는 것

\item[표현식(expression):] 하나의 결과값을 만드는 변수, 연산자, 값의 조합
\index{표현식 (expression)}
%\index{expression}

\item[부동 소수점(floating-point):] 소수점을 가진 숫자를 표현하는 자료형
\index{부동소수점 (floating-point)}
%\index{floating-point}

\item[버림 나눗셈(floor division)] 두 숫자를 나누어 소수점이하 부분을 절사하는 연산자
\index{버림 나눗셈 (floor division)}
%\index{floor division}

\item[정수(integer):] 완전수를 나타내는 자료형
\index{정수 (integer)}
%\index{integer}

\item[예약어(keyword):] 컴파일러가 프로그램을 파싱하는데 사용하기 위해서 이미 예약된 단어; if, def, while 같은 예약어를 변수명으로 사용할 수 없다.
\index{예약어 (keyword)}
%\index{keyword}

\item[연상기호(mnemonic):] 기억 보조. 변수에 저장된 것을 기억하기데 도움이 되도록 변수에 연상되는 이름을 부여한다.
\index{연상기호 (mnemonic)}
%\index{mnemonic}

\item[나머지 연산자(modulus operator):] 
퍼센트 기호 ({\tt \%})로 표시되고 정수를 가지고 한 숫자를 다른 숫자로 나누었을 때 나머지를 생성하는 연산자
\index{나머지 연산자 (modulus operator)}
\index{연산자 (operator)!나머지 (modulus)}
%\index{modulus operator}
%\index{operator!modulus}

\item[피연산자(operand):] 연산자가 연산을 수행하는 값중의 하나
\index{피연산자 (operand)}
%\index{operand}

\item[연산자(operator):] 덧셈, 곱셈, 문자열 결합 같은 간단한 연산을 표현하는 특별 기호
\index{연산자 (operator)}
%\index{operator}

\item[우선순위 규칙(rules of precedence):] 다수의 연산자와 피연산자를 포함한 표현식이 평가되는 실행 순서를 규정한 규칙 집합
\index{우선순위 규칙 (rules of precedence)}
\index{우선순위 (precedence)}
%\index{rules of precedence}
%\index{precedence}

\item[문장(statement):] 명령이나 액션을 나타내는 코드 부문. 지금까지 assignment, print 문을 보았다.
\index{문장 (statement)}
%\index{statement}

\item[문자열(string):] 일련의 문자를 나타내는 형식
\index{문자열 (string)}
%\index{string}

\item[자료형(type):] 값의 범주. 지금까지 여러분이 살펴본 자료형은 정수 ({\tt int}), 부동 소수점수 ({\tt float}), 문자열 ({\tt str}) 이다.
\index{자료형 (type)}
%\index{type}

\item[값(value):] 숫자나 문자 같은 프로그램이 다루는 데이터의 기본 단위중 하나
\index{값 (value)}
%\index{value}

\item[변수(variable):] 값을 참조하는 이름
\index{변수 (variable)}
%\index{variable}

\end{description}

\section{연습문제}

\begin{ex}
\verb"raw_input"을 사용하여 사용자의 이름을 입력받고 환영하는 프로그램을 작성하세요.

\begin{verbatim}
Enter your name: Chuck
Hello Chuck
\end{verbatim}

\end{ex}

\begin{ex}
급여를 지불하기 위해서 사용자로부터 근로시간과 시간당 임금을 계산하는 프로그램을 작성하세요.
\begin{verbatim}
Enter Hours: 35
Enter Rate: 2.75
Pay: 96.25
\end{verbatim}
\end{ex}
%
지금은 급여가 정확하게 소수점 두자리까지 표현되지 않아도 된다. 
만약 원하다면, 파이썬 내장 {\tt round} 함수를 사용하여 소수점 아래 두자리까지 반올림하여 작성할 수 있다.

\begin{ex}
다음 대입 문장을 실행한다고 가정합시다.

\begin{verbatim}
width = 17
height = 12.0
\end{verbatim}

다음 표현식 각각에 대해서, 표현식의 값(value)과 (표현식 값의) 자료형(type)을 작성하세요.

\begin{enumerate}

\item {\tt width/2}

\item {\tt width/2.0}

\item {\tt height/3}

\item {\tt 1 + 2 * 5}

\end{enumerate}

정답을 확인하기 위해서 파이썬 인터프리터를 사용하세요.

\end{ex}

\begin{ex}
사용자로부터 섭씨 온도를 입력받아 화씨온도로 변환하고, 변환된 온도를 출력하는 프로그램을 작성하세요.
\end{ex}


